<p>Overlord is an experimental build/module system for Common Lisp,
inspired by <a href="https://github.com/apenwarr/redo">Redo</a> and <a href="https://racket-lang.org/">Racket</a>. It is not another <code>defsystem</code>,
but a completely new approach.</p>

<p>A phrase like “inspired by Redo and Racket” needs unpacking. Overlord has
a stratified design. The bottom layer is a build system, inspired by
Redo. What makes Overlord different is that its dependency graph allows
both files and Lisp bindings as targets. The top layer is a module
system, inspired by Racket, for embedding languages into Lisp. You can
use the module system without knowing about the build system; you
can use the build system without knowing about the module system.</p>

<p>Overlord is experimental. Trying to document the API at this stage
would be futile. Instead, this README discusses the concepts behind
Overlord. If you’re looking for the current syntax, consult
the <a href="test.lisp">test suite</a> and the files it uses in <code>test/</code>.</p>

<p>(If you are interested in reading the code, the substance is
in <a href="impl.lisp">impl.lisp</a>; the rest is support.)</p>

<p>When I say “experimental”, I mean it. Anything may change at any time.
This code is not ready for use. It may not even be ready for release.</p>

<h1>Overlord vs. ASDF</h1>

<p>Overlord expects to be used alongside ASDF, with ASDF responsible for
compiling and loading Lisp code, and Overlord doing everything else.
(This works particularly well with ASDF’s <code>package-inferred-system</code>
style.)</p>

<p>Overlord is mostly independent of ASDF. It still, however, needs ASDF
to resolve relative pathnames. Depending on ASDF in this respect is
probably not unreasonable, since making it easy to locate a system’s
file is what ASDF was designed for.</p>

<p>(Note that, while Overlord is mostly independent of ASDF the program,
it still depends on ASDF the project, because it builds on the UIOP
portability layer.)</p>

<p>(Note that relying on ASDF means there is a discrepancy between path
names in Overlord modules, which are relative to the file, and path
names in Lisp files, which are relative to the system. This is
unlikely to change.)</p>

<h1>Overlord vs. Redo</h1>

<p>The most obvious, but least important, difference between Overlord and
Redo is that Redo uses shell scripts, while Overlord’s “scripts” are
written in Lisp. (It is unimportant because, after all, you can run
shell commands from Lisp, or somehow call Lisp from the shell.) On the
one hand, embedding shell syntax in Lisp is clumsy; on the other hand,
Lisp special variables are much superior to any shell-based means for
passing information between parent and child scripts. (See §5.4.2
in <a href="https://uwspace.uwaterloo.ca/handle/10012/2673">Grosskurth 2007</a>.)</p>

<p>The <em>important</em> difference is that Overlord uses <em>two</em> scripts per
target: one for building the target, and another for computing its
dependencies. This (mostly) replaces the need to maintain a database
of dependencies.</p>

<h1>Overlord and images</h1>

<p>During development, as targets are defined and re-defined, or rebuilt
or not rebuilt, the actual state of the Lisp world will drift away
from the one specified by Overlord’s dependency graph. Such
discrepancies are fine during development. Before dumping an image,
however, they must be resolved. It is obviously undesirable, for
example, for an image built on one machine to try to lazy-load a
module on another machine where the source of that module is
unavailable. (Actually it would be a disaster, since that source file
might be provided maliciously.)</p>

<p>Thus, before an image is saved, Overlord needs to do two things:</p>

<ol>
<li><p>Assure the state of the image by making sure that all defined
targets have been built.</p></li>
<li><p>Disable itself.</p></li>
</ol>

<p>If you use <code>uiop:dump-image</code> to save the image, you don’t need to do
anything; Overlord will assure the state of the image, and disable
itself, automatically.</p>

<p>If you are using implementation-specific means to save an image,
however, you will need to arrange to call <code>overlord:freeze</code> before the
image is saved.</p>

<h1>Overlord vs. Racket</h1>

<p>The following assumes some familiarity
with <a href="http://www.ccs.neu.edu/home/matthias/manifesto/">Racket</a>, and with subsequent work in Scheme
module systems.</p>

<p>A Overlord module is a <em>file</em> in a <em>language</em>. Overlord supports a
Racket-like hash-lang (<code>#lang</code>) syntax, but in Overlord the language
of a module can also be specified as part of the import syntax. Since
the language is not an inherent part of the file, the same file can be
loaded as a module in more than one language. And each language-file
combination gets its own, completely independent module.</p>

<h2>Languages</h2>

<p>In Racket, languages are defined in two steps. In Racket, a language
is a module. This module defines a reader, which returns syntax, and an
expander, which gives that syntax meaning.</p>

<p>That can’t work in Common Lisp, where meaning is assigned at read
time, when a symbol is interned in one or another package.</p>

<p>In Overlord, a language is just a package. The package exports a
reader and an expander. The symbol named <code>read-module</code> is the <em>package
reader</em>. The symbol named <code>module-progn</code> is the <em>package expander</em>.</p>

<p>The important thing: when the package’s reader is called, that same
package is also bound as the <em>current</em> package. It is then the
responsibility of the reader to make sure any symbols it reads in are
interned in the correct package. (There is a shortcut for this,
<code>overlord:reintern</code>.)</p>

<p>(There is one exception to the rule of <em>language=package</em>. If another
package exists, having the same name, but ending in <code>-user</code>, and this
other package inherits from the original package, then this <em>user
package</em> is the package that is made current while reading (and
expanding). E.g. a file beginning with <code>#lang cl</code> would actually be
read in using the <code>cl-user</code> package, not the <code>cl</code> package itself.)</p>

<p>In Racket the expander is entirely responsible for giving the code
meaning. In Overlord the expander has less to do, because the code has
been assigned meaning at read time, but it is still important for
lexical bindings and whole-program transformations.</p>

<p>Where in Racket you would write</p>

<pre><code>(module my-module MY-LANG forms ...)
</code></pre>

<p>to wrap FORMS with the binding of <code>#%module-begin</code> from MY-LANG, in
Overlord you just write:</p>

<pre><code>(MY-LANG:module-progn forms....)
</code></pre>

<p>Although for convenience you can write</p>

<pre><code>(overlord:module-progn-in :MY-LANG forms...)
</code></pre>

<p>But this just delays resolving <code>module-progn</code> from read time to
macro-expansion time.</p>

<p>Note that the reader is responsible for returning a single form, which
is the module. That is, the form returned by the package reader should
already be wrapped in the appropriate <code>module-progn</code>. The exported
binding for <code>module-progn</code> is <em>only</em> looked up when the language is
being used as the expander for a meta-language.</p>

<p>Meta-languages are for language authors who want to reuse an existing
syntax. E.g., if you want to define a language that uses
s-expressions, in Racket you can write:</p>

<pre><code>#lang s-exp my-lang
</code></pre>

<p>In Overlord you can do something similar:</p>

<pre><code>#lang overlord/s-exp my-lang
</code></pre>

<p>What happens here is simply that the <code>overlord/s-exp</code> language finds the
package <code>my-lang</code> and binds it to <code>*package*</code> <em>before</em> it starts
reading in forms.</p>

<h2>Defining languages</h2>

<p>Any package can be used as a hash lang, as long as its name is limited
to certain characters (<code>[a-zA-Z0-9/_+-]</code>). Of course this name can
also be a nickname.</p>

<p>(Note that resolution of package names is absolute, even in a Lisp
implementation that supports <a href="http://sbcl.org/manual/index.html#Package_002dLocal-Nicknames">package-local nicknames</a>.)</p>

<p>It is strongly recommended, although not required, that your language
package inherit from <code>overlord/shadows</code> rather than from <code>cl</code>. The
result is the same, except that <code>overlord/shadows</code> shadows Common
Lisp’s binding and definition forms so they can, in turn, be shadowed
in further language implementations.</p>

<p>The package must at least export a binding for one of <code>read-module</code>,
for direct use, or <code>module-progn</code>, for use with a meta-language.
Preferably, it would export both.</p>

<p>There are other special exports. For example, if there is a function
binding for <code>module-static-exports</code>, it is used, unsurprisingly, to
statically determine the module’s exports.</p>

<h2>Imports and exports.</h2>

<p>Overlord is very liberal about what can be a module. In Overlord, any
value can be a module – a string, a function, a hash table, anything –
and any module can provide exports as long as it specializes certain
generic functions, like <code>module-ref</code>.</p>

<p>Most of the time, however, what you want is <code>simple-module</code> (see below).</p>

<p>What Overlord imports and exports are not values, but bindings. Bindings
are indirect (and immutable): they refer to the module, rather than to
the value of the export. This allows for modules to be reloaded at any
time. It is even possible to unload modules.</p>

<p>The overhead of this indirection is very low, but when necessary it
can be avoided.</p>

<p>Note that exports in Overlord, with one exception, form a single
namespace. This is in order to keep the notation for imports simple.
Importing from a language with multiple namespaces into a language
with multiple namespaces would create a Cartesian product problem.</p>

<p>The one exception is macros. A Racket-style single namespace for
run-time bindings and macros would not make sense in Overlord where
modules can be dynamically reloaded.</p>

<p>Because Overlord imports bindings rather than values, modules are
always loaded lazily. A module is never actually loaded until a
function imported from it is called, or a variable imported from it is
looked up.</p>

<p>Finally, Overlord allows local imports. The combination of lazy loading
and local imports means that needless imports are minimized. For
example, a module that is only used inside of a macro will only be
loaded when the macro is expanded at compile time.</p>

<h2>Simple modules</h2>

<p>Most of the time, your language’s package expander will return a
<code>simple-module</code> form.</p>

<pre><code>(overlord:simple-module (#'moo)
  (defun make-moo (o)
    (concat "M" (make-string o :initial-element #\o)))

  (defun moo (&amp;optional (o 2))
    (print (make-moo o))))
</code></pre>

<p>This exports a single name, <code>moo</code>, bound to a function that says “Moo”
with a varying amount of “oo”.</p>

<p>What makes simple modules simple is that they cannot export macros. If
you do want to export macros, you need something more complex (see
below).</p>

<p>The <code>simple-module</code> form is is built on the support for internal
definitions in <a href="https://github.com/TBRSS/serapeum">Serapeum</a> (the <code>local</code> macro), and shares its
limitations with regard to the precedence of macro definitions. Macro
definitions must precede all function or variable definitions, and all
expressions.</p>

<h2>Macro exports</h2>

<p>Overlord’s syntax for import and export supports macros. Unlike in
Racket, macros must be imported explicitly as macros, because
implicitly distinguishing functions and macros does not make sense
when it is possible to reload modules.</p>

<p>I am not sure that support for macros in the module system is useful.
In Racket, where languages and modules are the same thing, modules
must export macros as language extensions. In Overlord, modules are
one thing, and languages are something else – packages.</p>

<p>That said, I could hardly call the module system “Racket-inspired”
with a straight face if it didn’t support exporting macros from
modules.</p>

<p>The ability to export macros from modules is not useful in itself. It
only becomes useful in the presence of certain forms of macro hygiene.
After experimenting with different ways to do this, I have concluded
that the correct thing to do, if you want your language to be able to
export macros, is to embed a hygiene-compatible language in Lisp, and
then compile your language to that.</p>

<p>I’m not being flippant. Embedding a hygiene-compatible language in CL
is not just doable; it’s <a href="http://www.jucs.org/jucs_16_2/embedding_hygiene_compatible_macros">already been done</a>. As a proof of
concept, I have converted Pascal’s Costanza’s hygiene-compatible
implementation of <a href="http://islisp.info/">ISLISP</a> in Common Lisp
(“<a href="http://www.p-cos.net/core-lisp.html">Core Lisp</a>”) to work with Overlord’s module system.
This version of Core Lisp lives in <a href="http://github.com/TBRSS/core-lisp">its own repository</a>.</p>

<p>How macro exports are supported is one aspect of the Overlord module
system that is very likely to change.</p>

<h1>Language examples</h1>

<p>Examples in general are hard. I think closures and macros are useful,
but I would have trouble producing an example of a problem that could
only be solved with closures, or a problem that could only be solved
with macros. The value of abstractions on the order of closures or
macros is not in solving any particular problem, but in the fluency
gained by having a single solution to a wide range of superficially
heterogenous problems. Likewise, I define languages all the time, but
most of them are too simple to serve as good examples.</p>

<p>Nonetheless, examples are necessary, so here are a few:</p>

<ol>
<li><p><a href="demo/js.lisp">overlord/demo/js</a>. A simple demo language built
on <a href="http://marijnhaverbeke.nl/cl-javascript/">CL-JavaScript</a>. It should succinctly illustrate the
challenges of converting an existing CL language implementation to
work with Overlord.</p></li>
<li><p><a href="http://github.com/TBRSS/bosom-serpent">Bosom Serpent</a>. Shows how to wrap a foreign runtime (Python,
using <a href="https://github.com/pinterface/burgled-batteries">burgled-batteries</a>) as an Overlord module.</p></li>
<li><p><a href="http://github.com/TBRSS/cl-yesql">cl-yesql</a>. Lisp port of Clojure’s <a href="https://github.com/krisajenkins/yesql">yesql</a>. Includes a parser,
and shows how (and why) to load the same file in different
languages.</p></li>
<li><p><a href="http://github.com/TBRSS/cl-https-everywhere">cl-https-everywhere</a>. In-process <a href="https://github.com/EFForg/https-everywhere">HTTPS Everywhere</a> rulesets.
Shows how to combine Overlord’s support for languages with direct
use of the build system.</p></li>
<li><p><a href="http://github.com/TBRSS/core-lisp">Core Lisp</a>. A hygiene-compatible implementation of the Lisp
dialect <a href="http://islisp.info/">ISLISP</a> (itself a conceptual subset of Common Lisp),
hopefully suitable as a base for building “language towers.”</p></li>
</ol>

<h1>Future work</h1>

<ul>
<li>Lots of tests.</li>
<li>More portability testing.</li>
<li>Leverage UIOP more.</li>
<li>Thread safety (and eventually parallelism).</li>
<li>Centralize Overlord fasls.</li>
<li>More expressive syntax for imports. (Compare <a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-10.html#node_chap_7">R6RS</a>.)</li>
<li>Better names for definition forms (e.g. <code>defconst/deps</code>).</li>
<li>Fewer dependencies.</li>
<li>Improve the Emacs integration (<a href="elisp/overlord.el">Prototype</a>.)</li>
<li>Improve the CLI. (Look in roswell/ and cl-launch/ for prototypes.)</li>
<li>A better name for the project?</li>
<li>Interfaces for modules?</li>
</ul>

<p>Things I might or might not do, but sure would like to link to if
someone else did them.</p>

<ul>
<li>A EBNF parser generator like <a href="http://www.hashcollision.org/ragg/">ragg</a> or <a href="https://github.com/Engelberg/instaparse">Instaparse</a>.</li>
<li>A simple lexer for a shell-like syntax (like <a href="https://github.com/python/cpython/blob/master/Lib/shlex.py">shlex</a>).</li>
<li>An <a href="https://docs.racket-lang.org/scribble/reader-internals.html">at-exp</a> meta-language.</li>
<li>A working <code>#lang scheme</code>. (Compare <a href="https://github.com/sharplispers/pseudoscheme">Pseudoscheme</a>).</li>
<li>A language for literate programming.</li>
<li>A language with an ML-style type system.</li>
<li><code>#lang shen</code>.</li>
<li>An array language.</li>
<li><code>#lang snowball</code> (the <a href="http://snowballstem.org">Snowball stemming language</a>).</li>
<li>A unit-aware language (compare <a href="https://frinklang.org">Frink</a>).</li>
<li>Any language or meta-language you care to implement.</li>
</ul>

<!-- NB Don’t remove links, even if they’re not currently being used.
You might want them again later. -->
