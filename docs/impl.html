<!DOCTYPE html>

<html>
<head>
  <title>impl.lisp</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="all.html">
                  all.lisp
                </a>
              
                
                <a class="source" href="base.html">
                  base.lisp
                </a>
              
                
                <a class="source" href="compile-to-file.html">
                  compile-to-file.lisp
                </a>
              
                
                <a class="source" href="file-package.html">
                  file-package.lisp
                </a>
              
                
                <a class="source" href="hash-lang.html">
                  hash-lang.lisp
                </a>
              
                
                <a class="source" href="hash-table-module.html">
                  hash-table-module.lisp
                </a>
              
                
                <a class="source" href="http.html">
                  http.lisp
                </a>
              
                
                <a class="source" href="impl.html">
                  impl.lisp
                </a>
              
                
                <a class="source" href="makefile.html">
                  makefile.lisp
                </a>
              
                
                <a class="source" href="module.html">
                  module.lisp
                </a>
              
                
                <a class="source" href="parsers.html">
                  parsers.lisp
                </a>
              
                
                <a class="source" href="safer-read.html">
                  safer-read.lisp
                </a>
              
                
                <a class="source" href="scripts.html">
                  scripts.lisp
                </a>
              
                
                <a class="source" href="shadows.html">
                  shadows.lisp
                </a>
              
                
                <a class="source" href="similarity.html">
                  similarity.lisp
                </a>
              
                
                <a class="source" href="simple-module.html">
                  simple-module.lisp
                </a>
              
                
                <a class="source" href="specials.html">
                  specials.lisp
                </a>
              
                
                <a class="source" href="types.html">
                  types.lisp
                </a>
              
                
                <a class="source" href="universal.html">
                  universal.lisp
                </a>
              
                
                <a class="source" href="util.html">
                  util.lisp
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>impl.lisp</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-name">defpackage</span> <span class="hljs-symbol">:overlord/impl</span>
  (<span class="hljs-symbol">:use</span>
    <span class="hljs-symbol">:cl</span>
    <span class="hljs-symbol">:alexandria</span>
    <span class="hljs-symbol">:serapeum</span>
    <span class="hljs-symbol">:local-time</span>

    <span class="hljs-symbol">:uiop/filesystem</span>
    <span class="hljs-symbol">:uiop/pathname</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>; Types common to the project.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    :overlord/types</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>; Special variables.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    :overlord/specials</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>; Module protocol.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    :overlord/module</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>; Utilities.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    :overlord/util</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>; How to infer the base for the current package.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    :overlord/base</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>; The #lang syntax.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    :overlord/hash-lang</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>; How to parse Makefiles.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    :overlord/makefile)</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>; Portability shim for “global” or “static” vars. They have global
; scope, but cannot be rebound.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (<span class="hljs-symbol">:import-from</span> <span class="hljs-symbol">:global-vars</span>
    <span class="hljs-symbol">:define-global-var</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>; How to compile a program to a fasl.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (<span class="hljs-symbol">:import-from</span> <span class="hljs-symbol">:overlord/compile-to-file</span>
    <span class="hljs-symbol">:compile-to-file</span> <span class="hljs-symbol">:load-as-module</span> <span class="hljs-symbol">:fasl-ext</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>; How to test similarity (CLHS 3.2.4.2.2) of externalizable objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (<span class="hljs-symbol">:import-from</span> <span class="hljs-symbol">:overlord/similarity</span>
    <span class="hljs-symbol">:similar</span>?)
  (<span class="hljs-symbol">:import-from</span> <span class="hljs-symbol">:uiop</span>
    <span class="hljs-symbol">:implementation-identifier</span>
    <span class="hljs-symbol">:with-temporary-file</span>
    <span class="hljs-symbol">:rename-file-overwriting-target</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>; How to escape names for use in pathnames.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (<span class="hljs-symbol">:import-from</span> <span class="hljs-symbol">:quri</span> <span class="hljs-symbol">:url-encode</span>)
  (<span class="hljs-symbol">:import-from</span> <span class="hljs-symbol">:cl-custom-hash-table</span>
    <span class="hljs-symbol">:define-custom-hash-table-constructor</span>
    <span class="hljs-symbol">:with-custom-hash-table</span>)
  (<span class="hljs-symbol">:shadow</span> <span class="hljs-symbol">:define-constant</span> <span class="hljs-symbol">:import</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>; Shadow for style.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (<span class="hljs-symbol">:shadow</span>
   <span class="hljs-symbol">:defmacro</span>                            <span class="hljs-comment">;Hygienic pathnames.</span>
   <span class="hljs-symbol">:if</span>                                  <span class="hljs-comment">;Always ternary.</span>
   <span class="hljs-symbol">:if-let</span>                              <span class="hljs-comment">;Ditto.</span>
   <span class="hljs-symbol">:cond</span>                                <span class="hljs-comment">;Require exhaustive.</span>
   <span class="hljs-symbol">:set</span>                                 <span class="hljs-comment">;Use `symbol-value'.</span>
   <span class="hljs-symbol">:defclass</span>                            <span class="hljs-comment">;Force checking slot types.</span>
   <span class="hljs-symbol">:typecase</span>                            <span class="hljs-comment">;Use typecase-of instead.</span>
   <span class="hljs-symbol">:etypecase</span>                           <span class="hljs-comment">;Use etypecase-of instead.</span>
   <span class="hljs-symbol">:ctypecase</span>                           <span class="hljs-comment">;Use ctypecase-of instead.</span>
   <span class="hljs-symbol">:file-write-date</span>                     <span class="hljs-comment">;Use file-mtime instead.</span>
   )
  (<span class="hljs-symbol">:export</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>; Defining and building targets.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>   :define-constant
   :defconst/deps
   :defvar/deps
   :deftask
   :file-target
   :undefine-target
   :build :unbuild :forget-target
   :run

   :*target*
   :ensure-absolute
   :extension
   :defpattern</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>; Languages.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>   :lang :lang-name :hash-lang-name
   :load-module
   :expand-module
   :depends-on
   :package-expander :package-reader :module-progn-in
   :with-meta-language
   :load-same-name-system
   :define-loader-language</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>; Loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>   :*language* :*source*
   :read-lang-name
   :require-as
   :dynamic-require-as</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>; Module protocol.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>   :module-meta

   :import :import/local
   :import-as-package
   :with-imports
   :reintern :reinterning
   :*file-local-variables*
   :find-module</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>; Emacs integration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>   :require-for-emacs
   :expand-module-for-emacs
   :freeze :freeze-policy
   :unfreeze))

(in-package :overlord/impl)</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>;; Shadows and preferred alternatives.</p>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>;; Resolve literal relative pathnames in macro bodies at compile
;; time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">cl</span><span class="hljs-symbol">:defmacro</span> defmacro (<span class="hljs-name">name</span> args <span class="hljs-symbol">&amp;body</span> body)
  (<span class="hljs-name">multiple-value-bind</span> (<span class="hljs-name">body</span> decls docstring)
      (<span class="hljs-name">parse-body</span> body <span class="hljs-symbol">:documentation</span> <span class="hljs-literal">t</span>)
    `(cl<span class="hljs-symbol">:defmacro</span> ,name ,args
       ,@(unsplice docstring)
       ,@decls</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>; Expand all literal relative pathnames.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>       (hygienic-pathnames
        (local ,@body)))))</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>;; Conditionals should always be exhaustive.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defmacro</span> if (<span class="hljs-name">test</span> then else)
  <span class="hljs-string">"Like `cl:if', but require two branches."</span>
  `(cl<span class="hljs-symbol">:if</span> ,test ,then ,else))

(<span class="hljs-name">defmacro</span> if-let (<span class="hljs-name">bindings</span> then else)
  <span class="hljs-string">"Like `alexandria:if-let', but require two branches."</span>
  `(alexandria<span class="hljs-symbol">:if-let</span> ,bindings ,then ,else))

(<span class="hljs-name">defmacro</span> cond (<span class="hljs-name">&amp;whole</span> whole <span class="hljs-symbol">&amp;body</span> clauses)
  <span class="hljs-string">"Like `cl:cond', but require a default clause."</span>
  (<span class="hljs-name">unless</span> (<span class="hljs-name">and</span> clauses (<span class="hljs-name">eql</span> (<span class="hljs-name">car</span> (<span class="hljs-name">lastcar</span> clauses)) 't))
    (<span class="hljs-name">warn</span> <span class="hljs-string">"Non-exhaustive COND: ~s"</span> whole))
  `(cl<span class="hljs-symbol">:cond</span> ,@clauses))

(<span class="hljs-name">defmacro</span> defclass (<span class="hljs-name">name</span> supers <span class="hljs-symbol">&amp;body</span> (<span class="hljs-name">slots</span> . options))
  <span class="hljs-string">"Like `cl:defclass', but try to force slot types to be checked.
Works for SBCL, at least."</span>
  `(locally (declare (optimize (safety <span class="hljs-number">3</span>)))
     (cl:defclass ,name ,supers
       ,slots
       ,@options)))</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>;; Make sure that we treat package names consistently, whether or not
;; the Lisp implementation uses package-relative nicknames.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defmacro</span> with-absolute-package-names ((<span class="hljs-name">&amp;key</span>) <span class="hljs-symbol">&amp;body</span> body)
  `(let ((*package* (find-package :keyword)))
     ,@body))</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>; Maybe this should shadow `find-package’; I’m not sure.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-name">defun</span> resolve-package (<span class="hljs-name">package-designator</span>)
  <span class="hljs-string">"Like `find-package', but make sure the package is resolved in
absolute terms even if the Lisp implementation supports local package
nicknames."</span>
  (<span class="hljs-name">with-absolute-package-names</span> ()
    (<span class="hljs-name">find-package</span> package-designator)))

(<span class="hljs-name">defun</span> file-mtime (<span class="hljs-name">pathname</span>)
  <span class="hljs-string">"Same as `file-write-date'.
This is provided in case we want to offer more precise timestamps on
Lisp/OS/filesystem combinations that support it."</span>
  (<span class="hljs-name">cl</span><span class="hljs-symbol">:file-write-date</span> pathname))

(<span class="hljs-name">defun</span> shuffle* (<span class="hljs-name">seq</span>)
  <span class="hljs-string">"Like `alexandria:shuffle', but non-destructive and returns a
  vector."</span>
  (<span class="hljs-name">shuffle</span> (<span class="hljs-name">copy-sequence</span> 'vector seq)))</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>;; Types.</p>

            </div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>;; A “singleton” type has exactly one instance, bound to a global
;; lexical of the same name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defmacro</span> define-singleton-type (<span class="hljs-name">name</span>)
  `(progn
     (deftype ,name ()
       '(eql ,name))
     (def ,name ',name)))</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>;; Timestamps can be exact timestamps (from local-time), universal
;; times, the singleton <code>never</code> (which means the target
;; unconditionally needs building) and the singleton <code>far-future</code>
;; (which means the target unconditionally does not need building).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">define-singleton-type</span> never)
(<span class="hljs-name">define-singleton-type</span> far-future)

(<span class="hljs-name">deftype</span> target-timestamp ()
  '(or timestamp
    universal-time
    never
    far-future))

(<span class="hljs-name">deftype</span> lang-name ()</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>; Keywords can be language names.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  '(and symbol (not (member t nil))))

(deftype hash-lang-name ()
  '(and lang-name (satisfies hash-lang-name?)))

(defun hash-lang-name? (x)
  (and (typep x 'lang-name)
       (valid-lang-name? (string x))))

(deftype lang ()
  '(or package lang-name))

(defclass ref ()
  ((name
    :reader ref-name
    :reader .name
    :type t
    :initarg :name))
  (:documentation "Base class for different kinds of by-name references."))

(defmethods ref (self)
  (:method initialize-instance :after (self &amp;key &amp;allow-other-keys)
    (unless (slot-boundp self 'name)
      (error* "No name")))

  (:method make-load-form (self &amp;optional env)
    (declare (ignore env))
    `(make-instance ,(class-of self)
                    :name ,(.name self))))

(defclass directory-ref (ref)
  ((name
    :initarg :path
    :type (and absolute-pathname directory-pathname)))
  (:documentation "A reference to a directory."))

(defun directory-ref (name)
  "Wrap NAME as a directory reference."
  (etypecase-of (or string directory-pathname) name
    (string (directory-ref (ensure-pathname name :want-pathname t)))
    (directory-pathname (make 'directory-ref :name name))))

(defclass package-ref (ref)
  ((name :type string)
   (nicknames
    :type list
    :initarg :nicknames
    :reader .nicknames)
   (use-list
    :type list
    :initarg :use
    :reader .use-list))
  (:documentation "A reference to a package.")
  (:default-initargs
   :nicknames nil
   :use-list nil))

(defmethods package-ref (self name nicknames use-list)
  (:method make-load-form (self &amp;optional env)
    (make-load-form-saving-slots self
                                 :slot-names '(name nicknames use-list)
                                 :environment env)))

(defun package-ref (name &amp;key nicknames use-list)
  (make 'package-ref :name (string name)
                     :nicknames nicknames
                     :use-list use-list))

(defclass pattern-ref (ref)</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>; Note that the pattern slot has no type: a pattern ref can be
; either a symbol or an instance of `pattern’, which is not yet
; defined. Being able to directly pass in patterns will be useful
; later when we bootstrap support for languages.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  ((pattern
    :initarg :pattern
    :type t
    :accessor .pattern)
   (name
    :type pathname
    :initarg :input
    :accessor .input)
   (output
    :type pathname
    :accessor .output)))

(defmethods pattern-ref (self)
  (:method initialize-instance :after (self &amp;key)</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>; Merge in the defaults for inputs and outputs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    (<span class="hljs-name">let*</span> ((<span class="hljs-name">pattern</span> (<span class="hljs-name">find-pattern</span> (.pattern self)))</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>; Note that we’re merging the <em>provided</em> inputs and
; outputs into the defaults, rather than vice-versa.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>           (<span class="hljs-name">input</span>
             (<span class="hljs-name">merge-pathnames*</span> (.input-defaults pattern)
                               (.input self)))
           (<span class="hljs-name">output</span>                      <span class="hljs-comment">;Careful about the order.</span>
             (<span class="hljs-name">merge-pathnames*</span> (.output-defaults pattern)</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>; .input, not .output.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                               (.input self))))
      (setf (.input self)  input
            (.output self) output)))

  (:method print-object (self stream)
    (print-unreadable-object (self stream :type t)
      (format stream "~a -&gt; ~a"
              (.input self)
              (.output self))))

  (:method make-load-form (self &amp;optional env)
    (make-load-form-saving-slots self
                                 :slot-names '(pattern name output)
                                 :environment env)))

(defun pattern-ref (pattern file)
  "Make a pattern reference, or a list of pattern references."</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>; TODO Should this be absolute?
; Shouldn’t this complain about relative vs. absolute?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (assure (or pattern-ref (list-of pattern-ref))
    (if (wild-pathname-p file)
        (mapcar (op (pattern-ref pattern _))
                (directory* file))
        (make 'pattern-ref
              :pattern pattern
              :input file))))

(defclass module-cell ()
  ((timestamp
    :type target-timestamp
    :initform never
    :accessor .timestamp)
   (lang
    :initarg :lang
    :type lang-name
    :reader .lang
    :reader module-cell-lang
    :reader module-lang)
   (source
    :initarg :source
    :type (and file-pathname tame-pathname)
    :reader .source
    :reader module-cell-source
    :reader module-source)
   (meta
    :initform nil
    :type plist
    :accessor .meta
    :documentation "Metadata about the module. This persists even when
the module is reloaded.")
   (module
    :initform nil
    :accessor .module)
   (lock
    :initform (bt:make-lock)
    :reader monitor))
  (:documentation "Storage for a module.

Each lang+source combination gets its own module cell with its own
unique identity.

The module itself may be reloaded, but the module cell is interned
forever."))

(defun module-cell-meta (cell key)
  (synchronized (cell)
    (getf (.meta cell) key)))

(defun (setf module-cell-meta) (value cell key)
  (synchronized (cell)
    (setf (getf (.meta cell) key)
          value)))

(defplace module-meta (lang path key)
  (module-cell-meta (module-cell lang path) key))

(define-compiler-macro module-meta (lang path key)
  "Expand the call to module-cell at compile time so it can be
resolved at load time."
  `(module-cell-meta (module-cell ,lang ,path) ,key))

(define-compiler-macro (setf module-meta) (value lang path key)
  `(setf (module-cell-meta (module-cell ,lang ,path) ,key) ,value))

(defmethods module-cell (self)
  (:method print-object (self stream)
    (print-unreadable-object (self stream :type t)
      (format stream "~a (~a)"
              (.source self)
              (.lang self))))

  (:method module-ref (self name)
    (module-ref* (.module self) name))

  (:method module-exports (self)
    (module-exports (.module self)))

  (:method make-load-form (self &amp;optional env)
    (declare (ignore env))
    `(module-cell ,(.lang self)
                  ,(assure absolute-pathname
                     (.source self)))))

(defun load-module-into-cell (cell)
  (lret ((module
          (assure (not null)
            (load-module (.lang cell)
                         (.source cell)))))
    (setf
     (.module cell) module
     (.timestamp cell) (now))))

(defclass makefile-target ()
  ((name :initarg :name :type string :reader .name)
   (dir :initarg :dir :type directory-pathname :reader .dir))
  (:default-initargs
   :name (error* "No name!")
   :dir (error* "No dir!"))
  (:documentation "A (possibly phony) target in a Makefile."))

(defun makefile-target (name &amp;optional (dir (base)))
  (make 'makefile-target
        :name name
        :dir (if (directory-pathname-p dir) dir
                 (pathname-directory-pathname dir))))

(defmethods makefile-target (self name dir)
  (:method makefile-target-file (self)
    (if (phony? name dir)
        (error* "~a is a phony target." self)
        (path-join dir name)))

  (:method print-object (self stream)
    (print-unreadable-object (self stream :type t)
      (format stream "-f ~s ~a" dir name)))

  (:method make-load-form (self &amp;optional env)
    (make-load-form-saving-slots self
                                 :slot-names '(name dir)
                                 :environment env)))

(defvar *building-root* nil)
(declaim (type boolean *building-root*))

(defstruct root-target
  "The root target; it depends on everything but nothing depends on
it."
  (timestamp never :type target-timestamp))

(defmethod print-object ((self root-target) stream)
  (print-unreadable-object (self stream :type t)))

(defvar *root-target*
  (prog1 (make-root-target)
    (fmakunbound 'make-root-target))
  "The one and only root target.")
(declaim (type root-target *root-target*))

(define-symbol-macro root-target *root-target*)

(deftype target ()</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>; NB Not allowing lists of targets as targets is a conscious
; decision. It would make things much more complicated. In
; particular, there would no longer be a single timestamp for a
; target, because the proper timestamp to use for a list of targets
; would depend on whether it was being depended on (in which case
; we want the /newest/ timestamp) or doing the depending (in which
; case we want the /oldest/ timestamp).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  '(or
    root-target
    bindable-symbol
    pathname
    package-ref
    directory-ref
    pattern-ref
    module-cell
    makefile-target))

(defvar-unbound *target*
  "The target being built.")
(declaim (type target *target*))</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>;; Targets.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defvar</span> *symbol-timestamps* (<span class="hljs-name">make-hash-table</span> <span class="hljs-symbol">:size</span> <span class="hljs-number">1024</span>))
(<span class="hljs-name">declaim</span> (<span class="hljs-name">type</span> hash-table *symbol-timestamps*))

(<span class="hljs-name">defun</span> pathname-exists? (<span class="hljs-name">path</span>)
  (<span class="hljs-name">etypecase-of</span> (<span class="hljs-name">or</span> string pathname) path
    (<span class="hljs-name">string</span> (<span class="hljs-name">pathname-exists</span>? (<span class="hljs-name">ensure-pathname</span> path <span class="hljs-symbol">:want-pathname</span> <span class="hljs-literal">t</span>)))
    (<span class="hljs-name">pathname</span>
     (<span class="hljs-name">or</span> (<span class="hljs-name">and</span> (<span class="hljs-name">handler-case</span>
                  (<span class="hljs-name">file-mtime</span> path)
                #+sbcl (<span class="hljs-name">sb-int</span><span class="hljs-symbol">:simple-file-error</span> () <span class="hljs-literal">nil</span>))
              (<span class="hljs-name">not</span> (<span class="hljs-name">directory-pathname-p</span> path)))</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>; TODO file-exists-p has (had?) a bug in CCL.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>         #+ () (file-exists-p path)
         (directory-exists-p path)))))

(defun target-timestamp (target)
  (etypecase-of target target
    (root-target (root-target-timestamp root-target))
    (bindable-symbol
     (if (boundp target)
         (let ((now (now)))
           (ensure2 (gethash target *symbol-timestamps*)
             now))
         never))
    (pathname
     (if (pathname-exists? target)
         (file-mtime target)
         never))
    (package-ref
     (let* ((name (ref-name target))
            (package (find-package (string name))))
       (if package far-future never)))
    (directory-ref
     (let ((dir (resolve-target (ref-name target) *base*)))
       (if (uiop:directory-exists-p dir)
           far-future
           never)))
    (pattern-ref
     (if (pathname-exists? (.output target))
         (file-mtime (.output target))
         never))
    (module-cell
     (if (null (.module target))
         never
         (.timestamp target)))
    (makefile-target
     (if (make-target-up-to-date? (.dir target) (.name target))
         far-future never))))

(defun (setf target-timestamp) (timestamp target)
  (check-type timestamp timestamp)
  (check-not-frozen)
  (etypecase-of target target
    (root-target (setf (root-target-timestamp root-target) timestamp))
    (bindable-symbol</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>; “Constants” need to set the timestamp while unbound.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>     #+ () (unless (boundp target)
             (error* "Trying to set timestamp for unbound symbol ~s"
                     target))
     (setf (gethash target *symbol-timestamps*) timestamp))
    (pathname
     (if (pathname-exists? target)</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>; TODO There must be some portable way to do this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>         (error* "Cannot set pathname timestamps (yet).")
         (open target :direction :probe :if-does-not-exist :create)))
    (directory-ref
     (let ((dir (.name target)))
       (if (directory-exists-p dir)</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>; TODO Ditto.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>           (error* "Cannot set directory timestamps (yet).")
           (ensure-directories-exist dir))))
    ((or pattern-ref package-ref)</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>; TODO Or does it?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>     (error* "Setting the timestamp of ~s does not make sense."))
    (module-cell
     (setf (.timestamp target) timestamp))
    (makefile-target
     (if (phony? (.name target) (.dir target))
         (error* "Cannot set the timestamp of a phony target.")
         (setf (target-timestamp (makefile-target-file target))
               timestamp)))))

(defun touch-target (target &amp;optional (date (now)))
  (setf (target-timestamp target) date))

(defun unbuild (target)
  "Destroy (\"unbuild\") TARGET.
E.g. delete a file, unbind a variable."
  (check-not-frozen)
  (etypecase-of target target
    (root-target)
    (bindable-symbol
     (makunbound target))
    (package-ref
     (delete-package (.name target)))
    (pathname
     (delete-file-or-directory (.name target)))
    (pattern-ref
     (delete-file-or-directory (.output target)))
    (directory-ref
     (delete-directory-tree (.name target)))
    (module-cell
     (with-slots (lang source) target
       (clear-module-cell lang source)
       (unbuild-lang-deps lang source)))
    (makefile-target</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>; TODO Does this make sense?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>     (delete-file (makefile-target-file target)))))

(defun delete-file-or-directory (p)
  (if (directory-pathname-p p)
      (delete-directory-tree p)
      (delete-file-if-exists p)))

(defun resolve-target (target base)
  (setf base (pathname-directory-pathname base))
  (when (typep base 'temporary-file)
    (simple-style-warning "Base looks like a temporary file: ~a" base))
  (etypecase-of target target
    ((or root-target bindable-symbol package-ref) target)
    (pathname
     (let ((path (merge-pathnames* target base)))
       (if (wild-pathname-p path)
           (directory* path)
           path)))
    (pattern-ref
     (pattern-ref (.pattern target)
                  (merge-pathnames* (.input target) base)))
    (directory-ref
     (directory-ref</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>; Could this be wild?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      (assure tame-pathname
        (merge-pathnames* (.name target) base))))
    (module-cell
     (locally
         #+sbcl (declare (notinline module-cell))
         (module-cell (.lang target)
                      (assure tame-pathname
                        (merge-pathnames* (.source target) base)))))
    (makefile-target
     (makefile-target (.name target) (.dir target)))))

(defparameter *preserve-fractional-seconds* nil
  "When comparing precise timestamps (local-time timestamps) and
  imprecise timestamps (universal times), should we conserve
  precision (convert the imprecise timestamp to a precise timestamp)
  or lose precision (convert the precise timestamp to an imprecise
  timestamp)?

  This matters at the REPL. It's perfectly possible to edit a file,
  build a target that depends on it, edit the file again, try to build
  it, and have nothing happen, because the file timestamp is not
  precise enough.

  Still, I'm not sure what the right thing to do here is -- which is
  why it is configurable. If I come to a definite decision, this
  parameter will be removed.")

(defun timestamp-newer? (ts1 ts2 &amp;key (precise *preserve-fractional-seconds*))</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>; NB Note that conversion from timestamp to universal rounds down
; (loses nsecs), so when comparing one of each, whether you convert
; the universal time to a timestamp, or the timestamp to a
; universal time, actually matters.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (etypecase-of target-timestamp ts1
    (timestamp
     (etypecase-of target-timestamp ts2
       (timestamp (timestamp&gt; ts1 ts2))
       (universal-time
        (if precise
            (timestamp&gt; ts1 (universal-to-timestamp ts2))
            (&gt; (timestamp-to-universal ts1) ts2)))
       (never t)
       (far-future nil)))
    (universal-time
     (etypecase-of target-timestamp ts2
       (universal-time (&gt; ts1 ts2))
       (timestamp
        (if precise
            (timestamp&gt; (universal-to-timestamp ts1) ts2)
            (&gt; ts1 (timestamp-to-universal ts2))))
       (never t)
       (far-future nil)))
    (never nil)
    (far-future t)))

(defun target-newer? (t1 t2)
  (timestamp-newer?
   (target-timestamp t1)
   (target-timestamp t2)))</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>;; Target table abstract data type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">deftype</span> target-table ()
  'hash-table)

(<span class="hljs-name">defun</span> target-type-of (<span class="hljs-name">x</span>)
  (<span class="hljs-name">typecase-of</span> target x
    (<span class="hljs-name">root-target</span> 'root-target)
    (<span class="hljs-name">bindable-symbol</span> 'bindable-symbol)
    (<span class="hljs-name">pathname</span> 'pathname)
    (<span class="hljs-name">module-cell</span> 'module-cell)
    (<span class="hljs-name">package-ref</span> 'package-ref)
    (<span class="hljs-name">directory-ref</span> 'directory-ref)
    (<span class="hljs-name">pattern-ref</span> 'pattern-ref)
    (<span class="hljs-name">makefile-target</span> 'makefile-target)</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>; Bottom.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    (otherwise nil)))

(defun target= (x y)
  "Are two targets the same?"
  (or (eql x y)
      (and (type= (target-type-of x) (target-type-of y))
           (etypecase-of target x
             (root-target t)            ;There's only one.
             (bindable-symbol (eql x y))
             (pathname (pathname-equal x y))
             (module-cell (eql x y))
             (package-ref
              (string= (.name x) (.name y)))
             (directory-ref
              (pathname-equal (.name x) (.name y)))
             (pattern-ref
              (and (equal (.input   x) (.input   y))
                   (eql   (.pattern x) (.pattern y))
                   (equal (.output  x) (.output  y))))
             (makefile-target
              (and (equal          (.name x) (.name y))
                   (pathname-equal (.dir  x) (.dir  y))))))))

(defun hash-target (target)
  (declare (optimize (speed 3)
                     (safety 1)
                     (debug 0)
                     (compilation-speed 0)))
  (etypecase-of target target
    ((or root-target bindable-symbol pathname)
     (sxhash target))
    (module-cell
     (dx-sxhash
      (list 'module-cell
            (module-cell-lang target)
            (module-cell-source target))))
    (makefile-target
     (dx-sxhash
      (list 'makefile-target
            (.name target)
            (.dir target))))
    (directory-ref
     (dx-sxhash
      (list 'directory-ref
            (.name target))))
    (package-ref
     (dx-sxhash
      (list 'package-ref
            (.name target))))
    (pattern-ref
     (dx-sxhash
      (list 'package-ref
            (.name target))))))

(define-custom-hash-table-constructor %make-target-table
  :test target=
  :hash-function hash-target)

(defun make-target-table (&amp;rest args &amp;key &amp;allow-other-keys)
  (apply #'%make-target-table args))

(defun target-table-ref (table key)
  (with-custom-hash-table
    (gethash key table)))

(defun (setf target-table-ref) (value table key)
  (with-custom-hash-table
    (setf (gethash key table) value)))

(defun target-table-member (table key)
  (nth-value 1
    (target-table-ref table key)))

(defun (setf target-table-member) (value table key)
  (prog1 value
    (if value
        (setf (target-table-ref table key) nil)
        (with-custom-hash-table
          (remhash key table)))))

(defun target-table-keys (table)
  (collecting
    (with-custom-hash-table
      (maphash (lambda (k v) (declare (ignore v))
                 (collect k))
               table))))

(defun clear-target-table (table)
  (with-custom-hash-table
    (clrhash table)))</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>;; Building.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">deftype</span> freeze-policy ()
  '(member t nil <span class="hljs-symbol">:hard</span>))

(<span class="hljs-name">defparameter</span> *freeze-policy* <span class="hljs-literal">t</span>)
(<span class="hljs-name">declaim</span> (<span class="hljs-name">type</span> freeze-policy *freeze-policy*))

(<span class="hljs-name">defun</span> freeze-policy ()
  *freeze-policy*)

(<span class="hljs-name">defun</span> (<span class="hljs-name">setf</span> freeze-policy) (<span class="hljs-name">value</span>)
  (<span class="hljs-name">setf</span> *freeze-policy* (<span class="hljs-name">assure</span> freeze-policy value)))

(<span class="hljs-name">defvar</span> *frozen* <span class="hljs-literal">nil</span>
  <span class="hljs-string">"Is the build system frozen?"</span>)

(<span class="hljs-name">defun</span> frozen? ()
  *frozen*)

(<span class="hljs-name">defun</span> freeze ()</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>; You should be able to load an image and save it again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (unless (frozen?)
    (flet ((freeze ()
             (format t "~&amp;Overlord: freezing image...~%")
             (build root-target)
             (setf *frozen* t))
           (hard-freeze ()
             (freeze)
             (format t "~&amp;Overlord: hard freeze...~%")
             (fmakunbound 'unfreeze)
             (clear-target-table *all-targets*)
             (clrhash *symbol-timestamps*)
             (clrhash *tasks*)
             (clrhash *patterns*)
             (clrhash *module-deps*)
             (clrhash *module-cells*)
             (clrhash *claimed-module-names*)
             (dolist (fn '(unfreeze build unbuild run dynamic-require-as))
               (fmakunbound fn))))
      (ecase-of freeze-policy *freeze-policy*
        ((nil))
        ((t) (freeze))
        (:hard (freeze))))))

(uiop:register-image-dump-hook 'freeze)

(defun unfreeze ()
  (setf *frozen* nil))

(defun check-not-frozen ()
  (when *frozen*
    (restart-case
        (error* "The build system is frozen.")
      (unfreeze ()
        :report "Unfreeze the build system."
        (setf *frozen* nil)))))

(defvar *tasks* (dict))
(declaim (type hash-table *tasks*))

(defvar *all-targets* (make-target-table :size 8192))
(declaim (type target-table *all-targets*))

(defun list-all-targets ()
  (append (hash-table-keys *tasks*)
          (target-table-keys *all-targets*)))

(defstruct-read-only (task
                      (:constructor task (target init deps))
                      (:conc-name task.))
  (target :type target)
  (init :type function)
  (deps :type function))

(defun save-task (target thunk deps)
  (check-not-frozen)
  (etypecase-of target target
    (root-target)
    ((or bindable-symbol pathname)
     (let ((task (task target thunk deps)))
       (setf (gethash target *tasks*) task)))
    ((or directory-ref package-ref pattern-ref module-cell makefile-target)
     (setf (target-table-member *all-targets* target) t)
     (values))))

(defun forget-target (target)
  (etypecase-of target target
    (root-target (error* "Cannot forget root target."))
    ((or bindable-symbol pathname)
     (remhash target *tasks*))
    ((or directory-ref package-ref pattern-ref module-cell makefile-target)
     (setf (target-table-member *all-targets* target) nil))))

(defun find-task (target)
  (check-not-frozen)
  (etypecase-of target target
    (root-target
     (let ((base (base)))
       (task target
             (constantly nil)
             (lambda ()
               (let ((*base* base)
                     (*building-root* t))</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>; (apply #’depends-on (list-all-targets))</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                 (~&gt;&gt; (list-all-targets)
                      shuffle*
                      (map nil #'depends-on)))))))
    ((or bindable-symbol pathname)
     (gethash target *tasks*))
    (directory-ref
     (let ((dir (ref-name target)))
       (task target
             (lambda ()
               (let ((dir (resolve-target dir *base*)))
                 (ensure-directories-exist dir)))
             (constantly nil))))
    (package-ref
     (task target
           (lambda ()
             (or (find-package (.name target))
                 (make-package (.name target)
                               :use (.use-list target)
                               :nicknames (.nicknames target))))
           (constantly nil)))
    (pattern-ref
     (let* ((input (.input target))
            (output (.output target))
            (pattern (find-pattern (.pattern target)))
            (init (.init pattern))
            (deps (.deps pattern)))
       (task output
             (lambda ()
               (let ((*input* input)
                     (*output* output))
                 (funcall init)))
             (lambda ()
               (let ((*input* input)
                     (*output* output))
                 (depends-on input)
                 (funcall deps))))))
    (module-cell
     (task target
           (lambda ()
             (let ((*language* (.lang target)))
               (load-module-into-cell target)))
           (lambda ()
             (let ((*base* (.source target))
                   (*language* (.lang target)))
               (with-defaults-from-base</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>; Depend on the source file.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                 (<span class="hljs-name">depends-on</span> (.source target))</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>; Let the language tell you what else to depend on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                 (<span class="hljs-name">lang-deps</span> (.lang target) (.source target))</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>; The stashed recursive dependencies of the module.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                 (dolist (dep (module-deps target))
                   (depends-on dep)))))))
    (makefile-target
     (let ((dir (.dir target))
           (name (.name target)))
       (task target
             (lambda ()
               (build-makefile-target dir name))
             (constantly nil))))))

(defcondition no-such-task (overlord-error)
  ((target :type target :initarg :target :reader .target))
  (:report (lambda (c s)
             (format s "No such task: ~a"
                     (.target c)))))

(defun no-such-task (target)
  (error 'no-such-task :target target))

(defcondition missing-file (no-such-task)
  ((target :type pathname))
  (:report (lambda (c s)
             (format s "Prerequisite ~s does not exist."
                     (.target c)))))

(defun missing-file (target)
  (error 'missing-file :target target))

(defun target-task (target &amp;optional (error-p t))
  (check-not-frozen)
  (or (find-task target)
      (if (pathnamep target)
          (if (pathname-exists? target)
              (task target (constantly nil) (constantly nil))
              (missing-file target))
          (if error-p
              (no-such-task target)
              nil))))

(defun target-task-values (target &amp;optional (error-p t))
  (let ((task (target-task target error-p)))
    (values (task.target task)
            (task.init task)
            (task.deps task))))

(defun build (target &amp;key (error-p t) force)
  (check-not-frozen)
  (multiple-value-bind (target thunk deps)
      (target-task-values target error-p)
    (build-task target thunk deps :force force)))

(defun system-loaded? (system)
  (let ((system (asdf:find-system system nil)))
    (and system
         (asdf:component-loaded-p system)
         system)))

(defun run (target system-name &amp;optional (package-name system-name))
  "Entry point for scripts."
  (let ((system-name (string-downcase system-name)) ;What ASDF wants.
        (target (coerce-case target))
        (package-name (coerce-case package-name)))
    (unless (system-loaded? system-name)
      (asdf:load-system system-name))
    (let ((package (find-package package-name)))
      (unless package
        (error* "No such package: ~s" package))
      (build (intern target package))
      (values target system-name package))))

(defun build-task (target thunk deps &amp;key force)
  (check-type thunk function)
  (check-type deps function)
  (check-not-frozen)
  (save-task target thunk deps)
  (build-recursively target :force force))

(defvar-unbound *already-built*
  "List of targets that have already been built.")
(declaim (type target-table *already-built*))

(defun already-built? (target)
  (target-table-member *already-built* target))

(defun build-recursively (target &amp;key force)
  (check-not-frozen)
  (labels
      ((build-deps (deps)
         (let ((*deps*))
           (funcall deps)
           (reverse *deps*)))

       (needs-building? (target deps-thunk)
         (let ((timestamp (target-timestamp target))
               (deps (build-deps deps-thunk)))</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>; Wait to check FORCE until after DEPS has been evaluated, in
; case it has side effects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>           (<span class="hljs-name">or</span> force</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>; NB Just because it’s never been built doesn’t
; mean it has no dependencies.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>               (or (eql timestamp never)
                   (some (op (timestamp-newer? _ timestamp))
                         (mapcar #'target-timestamp deps))))))

       (rec (target)
         (assure target-timestamp
           (if (already-built? target)
               (target-timestamp target)
               (progn
                 (setf (target-table-member *already-built* target) t)
                 (let ((*target* target))
                   (multiple-value-bind (target thunk deps)
                       (target-task-values target)
                     (when (needs-building? target deps)
                       (funcall thunk))
                     (target-timestamp target))))))))

    (handler-bind ((dependency #'redo))
      (let ((*already-built*
              (or (bound-value '*already-built*)
                  (make-target-table))))
        (rec target)))))

(defun redo (&amp;optional c)
  (when-let (r (find-restart 'redo c))
    (invoke-restart r)))

(defun rebuild-symbol (symbol thunk)
  (lambda ()
    (let ((*target* symbol))
      (setf (symbol-value symbol)     (funcall thunk)
            (target-timestamp symbol) (now)))))

(defun build-symbol (symbol thunk deps)
  (build-task symbol
              (rebuild-symbol symbol thunk)
              deps))

(defcondition dependency ()
  ((target :initarg :target</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>; Nothing can depend on the root target.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>           :type (and target (not root-target))
           :reader .target)))

(defun depends-on/1 (target)
  (let ((target (resolve-target target *base*)))
    (restart-case
        (signal 'dependency :target target)
      (continue ()
        :report "Ignore the dependency and move on.")
      (save ()
        :report "Save the dependency, but don't build it."
        (push target *deps*))
      (redo ()
        :report "Build the dependency."
        (push target *deps*)
        (build target)))))

(defun depends-on (&amp;rest deps)
  "Build DEPS in no particular order.
If any of DEPS is a list, its elements will also be added in no
particular order."</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>; NB This is where you would add parallelism.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (~&gt;&gt; deps
       (flatten-deps *base*)
       shuffle*
       (map nil #'depends-on/1))
  (values))

(defun depends-on* (&amp;rest deps)
  "Build DEPS in the order they are supplied.
If any of DEPS is a list, it will be descended into."
  (~&gt; deps
      (flatten-deps *base*)
      (mapc #'depends-on/1 _))
  (values))

(defun flatten-deps (base deps)</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>; We want lists of dependencies to be flattened.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (<span class="hljs-name">let</span> ((<span class="hljs-name">deps</span> (<span class="hljs-name">mappend</span> #'ensure-list deps)))</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>; A single target may resolve into multiple dependencies (e.g.
; patterns), but only to one level.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    (assure (list-of atom)
      (mappend (op (ensure-list (resolve-target _ base))) deps))))

(defun call/temp-file (dest fn)
  "Call FN on a freshly allocated temporary pathname; if it completes
safely, overwrite DEST with the contents of the temporary file."
  (let* ((ok nil)
         (tmp (with-temporary-file (:pathname p :keep t)
                (funcall fn p)
                (setq ok t)
                p)))
    (if ok</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>; Cross-device?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        #+ () (rename-file-overwriting-target tmp dest)
        (copy-file tmp dest :if-to-exists :rename-and-delete)
        (delete-file tmp))))

(defun rebuild-file (file thunk)
  (lambda ()
    (let* ((file (resolve-target file *base*))
           (*target* file)
           (old (target-timestamp file)))
      (funcall thunk)</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>; Since we depend on the granularity of the timestamps, all we can
; be sure of is that is not older than the old timestamp.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      (assert (not (timestamp-newer? old (target-timestamp file)))))))

(defmethod save-file-task ((file pathname) (thunk function) (deps function))
  (save-task file
             (rebuild-file file thunk)
             deps))

(defun build-constant (name new test)
  "Initialize NAME, if it is not set, or reinitialize it, if the old
value and NEW do not match under TEST."
  (let* ((*base* (if (boundp '*base*) *base* (base)))
         (old (symbol-value name)))
    (if (funcall test old new)
        old
        (progn
          (simple-style-warning "Redefining constant ~s" name)
          (funcall (rebuild-symbol name (lambda () new)))))))</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>;; Keyword macros.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defmacro</span> with-keyword-macros (<span class="hljs-name">&amp;body</span> body)
  `(macrolet ((:depends-on (x &amp;rest xs)
                `(depends-on ,x ,@xs))
              (:depends-on* (x &amp;rest xs)
                `(depends-on* ,x ,@xs))
              (:depends-on-all (xs)
                `(depends-on-all ,xs))
              (:package-exists (name &amp;key use nicknames)
                `(package-ref ,name :use ,use :nicknames ,nicknames))
              (:directory-exists (name)
                `(directory-ref ,name))
              (:pattern (name input)
                `(pattern-ref ,name ,input))
              (:module (lang source)
                `(module-cell ',lang ,source))
              (:extension (ext)
                `(extension ,ext))
              (:make (target)
                `(makefile-target ,target ,(base))))
     ,@body))</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>;; Bindings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defmacro</span> define-constant (<span class="hljs-name">name</span> init <span class="hljs-symbol">&amp;key</span> (<span class="hljs-name">test</span> '#'equal)
                                          documentation)
  (<span class="hljs-name">let</span> ((<span class="hljs-name">init</span>
          `(let ((*base* ,(base)))
             (with-defaults-from-base
               ,init))))
    `(progn
       (eval-always
         (define-global-var ,name
             (prog1 ,init
               (touch-target ',name
                             ,(if (boundp name)
                                  (assure target-timestamp
                                    (target-timestamp name))
                                  (now))))
           ,@(unsplice documentation)))
       (eval-always
         (save-task ',name (constantly ,init) (constantly <span class="hljs-literal">nil</span>)))
       (eval-always
         (build-constant ',name ,init ,test))
       ',name)))

(<span class="hljs-name">defmacro</span> deps-thunk (<span class="hljs-name">&amp;body</span> body)
  `(lambda ()
     (let ((*base* ,(base)))
       (with-defaults-from-base
         (with-keyword-macros
           ,@body)))))

(<span class="hljs-name">defmacro</span> init-thunk (<span class="hljs-name">&amp;body</span> body)
  `(lambda ()
     (let ((*base* ,(base)))
       (with-defaults-from-base
         (with-keyword-macros
           ,@body)))))

(<span class="hljs-name">defmacro</span> define-script (<span class="hljs-name">name</span> expr)
  `(define-constant ,name ',expr
     <span class="hljs-symbol">:test</span> #'source=))

(<span class="hljs-name">defmacro</span> with-script-dependency ((<span class="hljs-name">name</span> expr deps) <span class="hljs-symbol">&amp;body</span> body)
  (<span class="hljs-name">with-gensyms</span> (<span class="hljs-name">sn</span>)
    `(let* ((,sn (script-name ,name))
            (,deps (cons (list :depends-on (list 'quote ,sn)) ,deps)))
       (list
        'progn
        (list 'define-script ,sn ,expr)
        ,@body))))

(<span class="hljs-name">defun</span> script-name (<span class="hljs-name">name</span>)
  (<span class="hljs-name">intern</span> (<span class="hljs-name">coerce-case</span> (<span class="hljs-name">fmt</span> <span class="hljs-string">"~a.do"</span> name))
          (<span class="hljs-name">symbol-package</span> name)))

(<span class="hljs-name">defun</span> source= (<span class="hljs-name">x</span> y)</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>; TODO How to test equality in the presence of macros?
; Maybe expand with a code walker?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (similar? x y))

(defmacro undefine-target (name &amp;body body)
  (declare (ignore body))
  `(forget-target ',name))

(defmacro defvar/deps (name expr &amp;body deps)
  "Define a variable with dependencies.
A dependency can be a file or another variable.

If any of those files or variables change, then the variable is
rebuilt."
  (with-script-dependency (name expr deps)
    `(progn
       (defvar ,name)
       (build-symbol ',name
                     (init-thunk ,expr)
                     (deps-thunk ,@deps))
       ',name)))

(defmacro defconst/deps (name expr &amp;body deps)
  "Define a constant with dependencies.
A dependency can be a file or another variable.

If any of those files or variables change, then the variable is
rebuilt."
  `(progn</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>; The script must be available at compile time to be depended
; on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>     (define-script ,(script-name name) ,expr)
     (defconst/deps-aux ,name ,expr
       ,@deps)))

(defmacro defconst/deps-aux (name expr &amp;body deps)
  (mvlet* ((base (base))
           (*base* base)
           (deps
            `((:depends-on ',(script-name name))
              ,@deps))
           (init timestamp
            (progn
              (if (boundp name)
                  (build name)
                  (let ((deps-thunk (eval* `(deps-thunk ,@deps)))
                        (init-thunk (eval* `(init-thunk ,expr))))
                    (build-symbol name init-thunk deps-thunk)))
              (values (symbol-value name)
                      (target-timestamp name)))))
    `(progn
       (eval-always
         (define-global-var ,name
             (prog1 ',init
               (setf (target-timestamp ',name) ,timestamp))))
       (eval-always
         (build-symbol ',name
                       (init-thunk ,expr)
                       (deps-thunk ,@deps)))
       ',name)))

(defmacro file-target (name pathname (tmp) &amp;body (init . deps))</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>; An exception to the general rule that a file must always be
; specified as a pathname.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (<span class="hljs-name">setf</span> pathname (<span class="hljs-name">pathname</span> pathname))
  (<span class="hljs-name">check-type</span> pathname tame-pathname)
  (<span class="hljs-name">setf</span> pathname (<span class="hljs-name">resolve-target</span> pathname (<span class="hljs-name">base</span>)))
  (<span class="hljs-name">with-script-dependency</span> (<span class="hljs-name">name</span> init deps)
    `(progn
       (let ((*base* ,(base)))
         (with-defaults-from-base
           (save-file-task ,pathname
                           (init-thunk</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>; Write to a temp file and rename.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                             (call/temp-file ,pathname
                                             (lambda (,tmp)
                                               ,init)))
                           (deps-thunk ,@deps))))</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>; Make the task accessible by name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>       (save-task ',name
                  (constantly nil)
                  (deps-thunk
                    (:depends-on ,pathname)))
       ',pathname)))

(defmacro directory-target (name pathname (tmp) &amp;body (init . deps))</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>; Another exception.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (<span class="hljs-name">setf</span> pathname (<span class="hljs-name">pathname</span> pathname))
  (<span class="hljs-name">check-type</span> pathname tame-pathname)
  (<span class="hljs-name">setf</span> pathname (<span class="hljs-name">resolve-target</span> pathname (<span class="hljs-name">base</span>)))
  (<span class="hljs-name">check-type</span> pathname directory-pathname)
  (<span class="hljs-name">with-script-dependency</span> (<span class="hljs-name">name</span> init deps)
    `(progn
       (let ((*base* ,(base)))
         (with-defaults-from-base
           (save-file-task ,pathname
                           (init-thunk</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>; Write to a temp file and rename.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                             (call/temp-file ,pathname
                                             (lambda (,tmp)
                                               ,init)))
                           (deps-thunk ,@deps))))</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>; Make the task accessible by name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>       (save-task ',name
                  (constantly nil)
                  (deps-thunk
                    (:depends-on ,pathname)))
       ',pathname)))</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>;;; Phony targets.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defmacro</span> deftask (<span class="hljs-name">name</span> init <span class="hljs-symbol">&amp;body</span> deps)
  `(progn
     (save-task ',name
                (constantly <span class="hljs-literal">nil</span>)
                (lambda ()</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>; Phony targets don’t <em>need</em> to be built.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  (unless *building-root*
                    (funcall (deps-thunk ,@deps))
                    (funcall (init-thunk ,init)))))
     ',name))</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>;;; File patterns.</p>

            </div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>;; A pattern is an abstract relationship between two files.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defclass</span> pattern ()
  ((<span class="hljs-name">name</span>
    <span class="hljs-symbol">:initarg</span> <span class="hljs-symbol">:name</span>
    <span class="hljs-symbol">:accessor</span> .name
    <span class="hljs-symbol">:type</span> symbol)
   (<span class="hljs-name">input-defaults</span>
    <span class="hljs-symbol">:initarg</span> <span class="hljs-symbol">:input-defaults</span>
    <span class="hljs-symbol">:type</span> pathname
    <span class="hljs-symbol">:reader</span> .input-defaults)
   (<span class="hljs-name">output-defaults</span>
    <span class="hljs-symbol">:initarg</span> <span class="hljs-symbol">:output-defaults</span>
    <span class="hljs-symbol">:type</span> pathname
    <span class="hljs-symbol">:reader</span> .output-defaults)
   (<span class="hljs-name">init-fn</span>
    <span class="hljs-symbol">:initarg</span> <span class="hljs-symbol">:init</span>
    <span class="hljs-symbol">:type</span> function
    <span class="hljs-symbol">:reader</span> .init)
   (<span class="hljs-name">deps-fn</span>
    <span class="hljs-symbol">:initarg</span> <span class="hljs-symbol">:deps</span>
    <span class="hljs-symbol">:type</span> function
    <span class="hljs-symbol">:reader</span> .deps))
  (<span class="hljs-symbol">:default-initargs</span>
   <span class="hljs-symbol">:input-defaults</span> *nil-pathname*
   <span class="hljs-symbol">:output-defaults</span> *nil-pathname*
   <span class="hljs-symbol">:deps</span> (<span class="hljs-name">constantly</span> <span class="hljs-literal">nil</span>)
   <span class="hljs-symbol">:init</span> (<span class="hljs-name">constantly</span> <span class="hljs-literal">nil</span>)))

(<span class="hljs-name">defmethod</span> print-object ((<span class="hljs-name">self</span> pattern) stream)
  (<span class="hljs-name">print-unreadable-object</span> (<span class="hljs-name">self</span> stream <span class="hljs-symbol">:type</span> <span class="hljs-literal">t</span>)
    (<span class="hljs-name">format</span> stream <span class="hljs-string">"~s"</span> (.name self))))

(<span class="hljs-name">defun</span> extension (<span class="hljs-name">ext</span>)
  (<span class="hljs-name">assure</span> pathname
    (<span class="hljs-name">etypecase-of</span> (<span class="hljs-name">or</span> null string) ext
      (<span class="hljs-name">null</span> *nil-pathname*)
      (<span class="hljs-name">string</span> (<span class="hljs-name">make-pathname</span> <span class="hljs-symbol">:type</span> ext)))))

(<span class="hljs-name">defvar</span> *patterns* (<span class="hljs-name">make-hash-table</span> <span class="hljs-symbol">:size</span> <span class="hljs-number">1024</span>))

(<span class="hljs-name">defun</span> find-pattern (<span class="hljs-name">pattern</span> <span class="hljs-symbol">&amp;optional</span> (<span class="hljs-name">errorp</span> <span class="hljs-literal">t</span>))
  (<span class="hljs-name">assure</span> pattern
    (<span class="hljs-name">etypecase-of</span> (<span class="hljs-name">or</span> symbol pattern) pattern
      (<span class="hljs-name">pattern</span> pattern)
      (<span class="hljs-name">symbol</span>
       (<span class="hljs-name">multiple-value-bind</span> (<span class="hljs-name">pat</span> pat?)
           (<span class="hljs-name">gethash</span> pattern *patterns*)
         (<span class="hljs-name">cond</span> (<span class="hljs-name">pat</span>? pat)
               (<span class="hljs-name">errorp</span> (<span class="hljs-name">error*</span> <span class="hljs-string">"No such pattern: ~s"</span> pattern))
               (<span class="hljs-name">t</span> <span class="hljs-literal">nil</span>)))))))

(<span class="hljs-name">defmacro</span> defpattern (<span class="hljs-name">name</span> (<span class="hljs-name">in</span> out) options <span class="hljs-symbol">&amp;body</span> (<span class="hljs-name">init</span> . deps))
  <span class="hljs-string">"Define a file pattern named NAME.

Some build systems let you define file patterns based on extensions or
regular expressions. That won't work for Overlord, because there is no
special namespace for targets, so such a rule would apply everywhere.
It has to have a name.

A file pattern in Overlord must have a name. You use it like this:

    (:depend-on (:pattern 'my-pattern \"file\"))

If you set the input pathname defaults, you don't have to give an
extension to the file.

Based on the pattern, the output file is calculated, and the result
depends on that."</span>
  (<span class="hljs-name">let</span> ((<span class="hljs-name">script-name</span> (<span class="hljs-name">script-name</span> name)))
    `(progn
       (define-script ,script-name ,(list* in out init))
       (eval-always
         (with-keyword-macros
           (save-pattern
            ',name
            (lambda ()
              (let ((,in *input*)
                    (,out *output*))
                (declare (ignorable ,in ,out))
                ,init))
            (lambda ()
              (let ((,in *input*)
                    (,out *output*))
                (declare (ignorable ,out))
                (funcall
                 (deps-thunk
                   (:depends-on ',script-name)
                   (:depends-on ,in)
                   ,@deps))))
            ,@options))))))

(<span class="hljs-name">defun</span> save-pattern (<span class="hljs-name">name</span> init deps <span class="hljs-symbol">&amp;rest</span> options)
  (<span class="hljs-name">let</span> ((<span class="hljs-name">pattern</span>
          (<span class="hljs-name">apply</span> #'make 'pattern
                 <span class="hljs-symbol">:name</span> name
                 <span class="hljs-symbol">:init</span> init
                 <span class="hljs-symbol">:deps</span> deps
                 options)))
    (<span class="hljs-name">setf</span> (<span class="hljs-name">gethash</span> name *patterns*) pattern)))</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>;; Languages</p>

            </div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>;; Note that support for languages follows support for file patterns.
;; A pattern is an abstract relationship between two files; a
;; language is an abstract relationship between a file and Lisp
;; binding.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defparameter</span> *fasl-version* <span class="hljs-number">1</span>
  <span class="hljs-string">"Versioning for fasls.
Incrementing this should be sufficient to invalidate old fasls."</span>)
(<span class="hljs-name">declaim</span> (<span class="hljs-name">type</span> (<span class="hljs-name">integer</span> <span class="hljs-number">1</span> *) *fasl-version*))</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>;; Module dependencies: when compiling module X requires module Y,
;; save the information that X depends on Y so Y can be checked when
;; determining if X needs rebuilding.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defvar-unbound</span> *module-chain*
  <span class="hljs-string">"The chain of modules being loaded."</span>)

(<span class="hljs-name">defvar</span> *module-deps* (<span class="hljs-name">dict</span>))

(<span class="hljs-name">defmethod</span> module-deps ((<span class="hljs-name">m</span> module-cell))
  (<span class="hljs-name">gethash</span> m *module-deps*))

(<span class="hljs-name">defmethod</span> (<span class="hljs-name">setf</span> module-deps) ((<span class="hljs-name">value</span> list) (<span class="hljs-name">m</span> module-cell))
  (<span class="hljs-name">setf</span> (<span class="hljs-name">gethash</span> m *module-deps*) value))

(<span class="hljs-name">defun</span> flatten-module-deps (<span class="hljs-name">m</span>)
  (<span class="hljs-name">collecting</span>
    (<span class="hljs-name">labels</span> ((<span class="hljs-name">rec</span> (<span class="hljs-name">m</span>)
               (<span class="hljs-name">collect</span> m)
               (<span class="hljs-name">dolist</span> (<span class="hljs-name">d</span> (<span class="hljs-name">module-deps</span> m))
                 (<span class="hljs-name">rec</span> d))))
      (<span class="hljs-name">rec</span> m))))

(<span class="hljs-name">defmacro</span> with-module-dependency-tracking ((<span class="hljs-name">&amp;key</span>) <span class="hljs-symbol">&amp;body</span> body)
  <span class="hljs-string">"Sugar for `call/module-dependency-tracking'."</span>
  (<span class="hljs-name">with-thunk</span> (<span class="hljs-name">body</span>)
    `(call/module-dependency-tracking ,body)))

(<span class="hljs-name">defun</span> call/module-dependency-tracking (<span class="hljs-name">thunk</span>)
  <span class="hljs-string">"Ensure that `*module-chain*' is bound around THUNK."</span>
  (<span class="hljs-name">if</span> (<span class="hljs-name">boundp</span> '*module-chain*)
      (<span class="hljs-name">funcall</span> thunk)
      (<span class="hljs-name">let</span> ((<span class="hljs-name">*module-chain*</span> '()))
        (<span class="hljs-name">funcall</span> thunk))))

(<span class="hljs-name">defun</span> save-module-dependency (<span class="hljs-name">mc</span>)
  (<span class="hljs-name">check-type</span> mc module-cell)
  (<span class="hljs-name">assert</span> (<span class="hljs-name">boundp</span> '*module-chain*))
  (<span class="hljs-name">when-let</span> (<span class="hljs-name">prev</span> (<span class="hljs-name">first</span> *module-chain*))
    (<span class="hljs-name">pushnew</span> mc (<span class="hljs-name">module-deps</span> prev)))
  (<span class="hljs-name">push</span> mc *module-chain*))

(<span class="hljs-name">defun</span> %require-as (<span class="hljs-name">lang</span> source *base* <span class="hljs-symbol">&amp;rest</span> args)
  (<span class="hljs-name">with-defaults-from-base</span>
    (<span class="hljs-name">apply</span> #'dynamic-require-as
           lang
           (<span class="hljs-name">merge-pathnames*</span> source *base*)
           args)))

(<span class="hljs-name">defun</span> dynamic-require-as (<span class="hljs-name">lang</span> source <span class="hljs-symbol">&amp;key</span> force)
  #+sbcl (<span class="hljs-name">declare</span> (<span class="hljs-name">notinline</span> module-cell))
  (<span class="hljs-name">check-type</span> source (<span class="hljs-name">and</span> absolute-pathname file-pathname))
  (<span class="hljs-name">setf</span> lang (<span class="hljs-name">or</span> lang (<span class="hljs-name">guess-lang+pos</span> source)))
  (<span class="hljs-name">when</span> force
    (<span class="hljs-name">dynamic-unrequire-as</span> lang source))
  (<span class="hljs-name">with-module-dependency-tracking</span> ()
    (<span class="hljs-name">let</span> ((<span class="hljs-name">mc</span> (<span class="hljs-name">module-cell</span> lang source)))
      (<span class="hljs-name">save-module-dependency</span> mc)
      (<span class="hljs-name">build</span> mc)
      (.module mc))))

(<span class="hljs-name">defun</span> %unrequire-as (<span class="hljs-name">lang</span> source *base*)
  (<span class="hljs-name">with-defaults-from-base</span>
    (<span class="hljs-name">dynamic-unrequire-as</span> lang
                          (<span class="hljs-name">merge-pathnames*</span> source *base*))))

(<span class="hljs-name">defun</span> dynamic-unrequire-as (<span class="hljs-name">lang</span> source)
  #+sbcl (<span class="hljs-name">declare</span> (<span class="hljs-name">notinline</span> module-cell))
  (<span class="hljs-name">check-type</span> source (<span class="hljs-name">and</span> absolute-pathname file-pathname))
  (<span class="hljs-name">clear-module-cell</span> lang source)
  (<span class="hljs-name">values</span>))

(<span class="hljs-name">defmacro</span> require-as (<span class="hljs-name">lang</span> source)
  `(%require-as ,lang ,source ,(base)))

(<span class="hljs-name">defun</span> require-for-emacs (<span class="hljs-name">lang</span> source)
  <span class="hljs-string">"Like `dynamic-require-as', but with looser restrictions for easy
interoperation with Emacs."</span>
  (<span class="hljs-name">let</span> ((<span class="hljs-name">lang</span>
          (<span class="hljs-name">resolve-lang</span> lang))
        (<span class="hljs-name">source</span>
          (<span class="hljs-name">assure</span> absolute-pathname
            (<span class="hljs-name">pathname</span> source))))
    (<span class="hljs-name">dynamic-require-as</span> lang source)
    (<span class="hljs-name">values</span>)))

(<span class="hljs-name">defmacro</span> unrequire-as (<span class="hljs-name">lang</span> source)
  `(%unrequire-as ,lang ,source ,(base)))

(<span class="hljs-name">defun</span> escape-lang-name (<span class="hljs-name">lang-name</span>)
  (<span class="hljs-name">check-type</span> lang-name lang-name)
  (<span class="hljs-name">url-encode</span> (<span class="hljs-name">string</span> lang-name) <span class="hljs-symbol">:encoding</span> <span class="hljs-symbol">:utf-8</span>))

(<span class="hljs-name">defun</span> fasl-dir (<span class="hljs-name">lang</span>)
  (<span class="hljs-name">let</span> ((<span class="hljs-name">impl-id</span> (<span class="hljs-name">implementation-identifier</span>))
        (<span class="hljs-name">lang-string</span> (<span class="hljs-name">escape-lang-name</span> lang)))
    `(<span class="hljs-symbol">:relative</span> <span class="hljs-string">".overlord"</span>
                <span class="hljs-string">"fasls"</span>
                ,(fmt <span class="hljs-string">"~a"</span> *fasl-version*)
                ,impl-id</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>; XXX Package? TODO</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                ,lang-string)))

(defun faslize (lang pathname)
  (etypecase-of lang lang
    (package (faslize (package-name-keyword lang) pathname))
    (lang-name
     (merge-pathnames*
      (make-pathname :directory (fasl-dir lang)
                     :name (pathname-name pathname)
                     :type fasl-ext)
      pathname))))

(defun fasl? (pathname)
  (equal (pathname-type pathname)
         fasl-ext))

(defun load-module (lang source)
  (let* ((source (pathname source))
         (*base* source))
    (with-defaults-from-base
      (load-fasl-lang lang source))))

(defun module-static-exports (lang source)
  (check-type source absolute-pathname)
  (let ((lang (resolve-lang-package lang)))
    (if-let (sym (find-external-symbol 'static-exports lang))
      (funcall sym source)
      (module-exports (dynamic-require-as lang source)))))</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>;; Module cells.</p>

            </div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>;; The idea here is to avoid runtime lookups of modules by interning
;; mutable cells instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defvar</span> *module-cells* (<span class="hljs-name">dict</span>))

(<span class="hljs-name">defun</span> %ensure-module-cell (<span class="hljs-name">lang</span> path)
  <span class="hljs-string">"Get the module cell for LANG and PATH, creating and interning one
if it does not exist."</span>
  (<span class="hljs-name">check-type</span> path absolute-pathname)
  (<span class="hljs-name">setf</span> path
        (<span class="hljs-name">assure</span> pathname
          (<span class="hljs-name">or</span> (<span class="hljs-name">truename*</span> path)
              (<span class="hljs-name">error</span> <span class="hljs-string">"Cannot resolve pathname ~a"</span> path))))
  (<span class="hljs-name">mvlet*</span> ((<span class="hljs-name">key</span> (<span class="hljs-name">cons</span> lang path))
           (<span class="hljs-name">cell</span> cell?
            (<span class="hljs-name">gethash</span> key *module-cells*)))
    (<span class="hljs-name">if</span> cell? (<span class="hljs-name">assure</span> module-cell cell)
        (<span class="hljs-name">let</span> ((<span class="hljs-name">cell</span> (<span class="hljs-name">make</span> 'module-cell <span class="hljs-symbol">:lang</span> lang <span class="hljs-symbol">:source</span> path)))
          (<span class="hljs-name">setf</span> (<span class="hljs-name">gethash</span> key *module-cells*) cell)))))

(<span class="hljs-name">defun</span> module-cell (<span class="hljs-name">lang</span> path)
  (<span class="hljs-name">let</span> ((<span class="hljs-name">path</span>
          (<span class="hljs-name">assure</span> absolute-pathname
            (<span class="hljs-name">merge-input-defaults</span> lang (<span class="hljs-name">pathname</span> path))))
        (<span class="hljs-name">lang</span> (<span class="hljs-name">lang-name</span> lang)))
    (%ensure-module-cell lang path)))

(<span class="hljs-name">defun</span> find-module (<span class="hljs-name">lang</span> source)
  (.module (<span class="hljs-name">module-cell</span> lang source)))

(<span class="hljs-name">define-compiler-macro</span> find-module (<span class="hljs-name">lang</span> source)
  `(.module (module-cell ,lang ,source)))

(<span class="hljs-name">defun</span> merge-input-defaults (<span class="hljs-name">lang</span> path)
  <span class="hljs-string">"Merge PATH with the input defaults of LANG.
The input defaults override PATH where they conflict."</span></pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>; TODO Which should win? Inputs or defaults? Providing an explicit
; extension vs. providing an implicit module path.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (merge-pathnames* (.input-defaults lang) path))</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>;; Hack to stop recursion. We can’t use %ensure-module-cell directly,
;; because it doesn’t apply the defaults for the language.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-name">declaim</span> (<span class="hljs-name">notinline</span> %module-cell))
(<span class="hljs-name">defun</span> %module-cell (<span class="hljs-name">lang</span> path)
  (<span class="hljs-name">declare</span> (<span class="hljs-name">notinline</span> module-cell))
  (<span class="hljs-name">module-cell</span> lang path))

(<span class="hljs-name">define-compiler-macro</span> module-cell (<span class="hljs-name">&amp;whole</span> call lang path)
  (<span class="hljs-name">cond</span> ((<span class="hljs-name">packagep</span> lang)
         `(module-cell ,(lang-name lang) ,path))
        ((<span class="hljs-name">or</span> (<span class="hljs-name">quoted-symbol</span>? lang) (<span class="hljs-name">keywordp</span> lang))
         (<span class="hljs-name">typecase-of</span> (<span class="hljs-name">or</span> string pathname) path
           (<span class="hljs-name">string</span> `(module-cell ,lang ,(pathname path)))
           (<span class="hljs-name">pathname</span>
            (<span class="hljs-name">let</span> ((<span class="hljs-name">path</span> (<span class="hljs-name">resolve-target</span> path (<span class="hljs-name">base</span>)))) <span class="hljs-comment">;Resolve now, while `*base*' is bound.</span>
              `(load-time-value
                (%module-cell ,lang ,path))))
           (<span class="hljs-name">otherwise</span> call)))
        ((<span class="hljs-name">constantp</span> lang)
         (<span class="hljs-name">let</span> ((<span class="hljs-name">val</span> (<span class="hljs-name">eval</span> lang)))
           (<span class="hljs-name">if</span> (<span class="hljs-name">eql</span> val lang) call
               `(module-cell ,val ,path))))
        (<span class="hljs-name">t</span> call)))

(<span class="hljs-name">defun</span> clear-module-cell (<span class="hljs-name">lang</span> source)
  (<span class="hljs-name">declare</span> (<span class="hljs-name">notinline</span> module-cell))
  (<span class="hljs-name">lret</span> ((<span class="hljs-name">m</span> (<span class="hljs-name">module-cell</span> lang source)))
    (<span class="hljs-name">setf</span> (.timestamp m) never)
    (<span class="hljs-name">nix</span> (.module m))))</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>;; Lazy-loading modules.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defun</span> load-module/lazy (<span class="hljs-name">lang</span> source)
  (<span class="hljs-name">load-module-into-cell/lazy</span>
   (<span class="hljs-name">module-cell</span> lang source)))

(<span class="hljs-name">define-compiler-macro</span> load-module/lazy (<span class="hljs-name">lang</span> path)
  `(load-module-into-cell/lazy (module-cell ,lang ,path)))

(<span class="hljs-name">defun</span> load-module-into-cell/lazy (<span class="hljs-name">cell</span>)
  (<span class="hljs-name">with-slots</span> (<span class="hljs-name">module</span> lang source) cell</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>; “Double-checked locking.”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    (or module
        (synchronized (cell)
          (or module
              (progn
                (build cell)
                module))))))</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>;; Languages.</p>

            </div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>;; This is a generic function so individual langs can define their
;; own dependencies in :after methods.</p>

            </div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>;; TODO Should this use the progn method combination?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-name">defgeneric</span> lang-deps (<span class="hljs-name">lang</span> source)
  (<span class="hljs-symbol">:method</span> ((<span class="hljs-name">lang</span> <span class="hljs-literal">t</span>) (<span class="hljs-name">source</span> <span class="hljs-literal">t</span>))
    <span class="hljs-literal">nil</span>)

  (<span class="hljs-symbol">:method</span> ((<span class="hljs-name">lang</span> symbol) (<span class="hljs-name">source</span> <span class="hljs-literal">t</span>))
    (<span class="hljs-name">lang-deps</span> (<span class="hljs-name">resolve-lang-package</span> lang) source)))

(<span class="hljs-name">defgeneric</span> unbuild-lang-deps (<span class="hljs-name">lang</span> source)
  (<span class="hljs-symbol">:method</span> ((<span class="hljs-name">lang</span> <span class="hljs-literal">t</span>) (<span class="hljs-name">source</span> <span class="hljs-literal">t</span>))
    <span class="hljs-literal">nil</span>)

  (<span class="hljs-symbol">:method</span> ((<span class="hljs-name">lang</span> symbol) (<span class="hljs-name">source</span> <span class="hljs-literal">t</span>))
    (<span class="hljs-name">unbuild-lang-deps</span> (<span class="hljs-name">resolve-lang</span> lang) source)))

(<span class="hljs-name">defmethod</span> .input-defaults ((<span class="hljs-name">lang</span> symbol))
  (<span class="hljs-name">let</span> ((<span class="hljs-name">p</span> (<span class="hljs-name">resolve-package</span> lang)))
    (<span class="hljs-name">if</span> p (.input-defaults p) *nil-pathname*)))

(<span class="hljs-name">defmethod</span> .input-defaults ((<span class="hljs-name">p</span> package))
  (<span class="hljs-name">let</span> ((<span class="hljs-name">sym</span> (<span class="hljs-name">find-symbol</span> #.(<span class="hljs-name">string</span> 'extension) p)))
    (<span class="hljs-name">or</span> (<span class="hljs-name">and</span> sym (<span class="hljs-name">symbol-value</span> sym))
        *nil-pathname*)))

(<span class="hljs-name">defmacro</span> define-loader-language (<span class="hljs-name">package-name</span> (<span class="hljs-name">source</span>) <span class="hljs-symbol">&amp;body</span> (<span class="hljs-name">reader</span> <span class="hljs-symbol">&amp;key</span> extension))
  (<span class="hljs-name">let*</span> ((<span class="hljs-name">pn</span> (<span class="hljs-name">string</span> package-name)))</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>; Sanity check: are we overwriting an existing package?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    (when-let (package (find-package pn))
      (when (package-use-list package)
        (error* "Package already exists with a use list: ~a" package))
      (unless (set-equal (package-exports package)
                         (loader-language-exports)
                         :test #'string=)
        (error* "Package already exists with wrong exports: ~a" package)))
    `(progn
       (defpackage ,pn
         (:use)
         (:export ,@(loader-language-exports)))
       (define-loader-language-1 ,pn (,source)
         ,reader
         :extension ,extension))))

(defmacro define-loader-language-1 (package-name (source) &amp;body (reader &amp;key extension))
  "The part that gets expanded once PACKAGE-NAME exists."
  (let* ((reader (hygienic-pathnames reader))
         (p (find-package package-name))
         (syms (mapcar (op (find-sym _ p)) (loader-language-exports))))
    (destructuring-bind (load read ext script) syms
      `(progn
         (declaim (notinline ,load ,read))
         (eval-always
           (define-script ,script ,reader)
           (defparameter ,ext (extension ,extension))
           (defun ,load (,source)
             ,reader)
           (defun ,read (,source _stream)
             (declare (ignore _stream))
             (list ',load ,source))
           (defmethod lang-deps :after ((self (eql ,(make-keyword package-name))) source)
             (declare (ignore source))
             (depends-on ',script)))))))

(defun load-fasl-lang (lang source)
  (let ((object-file (faslize lang source)))
    (restart-case
        (load-as-module object-file)
      (recompile-object-file ()
        :report "Recompile the object file."
        (delete-file-if-exists object-file)
        (build (module-cell lang source))
        (load-fasl-lang lang source)))))

(defmethod lang-deps ((lang package) (source pathname))
  (let* ((pat (fasl-lang-pattern lang source))
         (ref (pattern-ref pat source)))
    (depends-on ref)))

(defmethod unbuild-lang-deps ((lang package) (source pathname))
  (delete-file-if-exists (faslize lang source)))

(defun lang-name (lang)
  (etypecase-of lang lang
    (keyword lang)
    (lang-name (make-keyword lang))
    (package (package-name-keyword lang))))

(defun fasl-lang-pattern (lang source)
  (make 'pattern
        :name (lang-name lang)
        :output-defaults (faslize lang source)</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>; Bear in mind <em>input</em> may have been resolved.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        :init (lambda ()</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>; TODO Should we reset the deps first?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                (let ((*source* *input*)
                      (*language* (lang-name lang)))
                  (compile-to-file
                   (~&gt; (expand-module lang *input*)
                       (wrap-current-module lang *input*))
                   (ensure-directories-exist *output*)
                   :top-level (package-compile-top-level? lang)))
                (save-module-deps lang *input*))
        :deps (lambda ()
                (loop for dep in (module-static-dependencies lang *input*) do
                  (depends-on dep)))))

(defun save-module-deps (lang source)
  (setf lang (lang-name lang))
  (let* ((mc (module-cell lang source))
         (deps (module-deps mc))
         (file (deps-file lang source)))
    (with-output-to-file (s file :if-exists :supersede)
      (with-standard-io-syntax
        (loop for mc in deps
              for lang = (.lang mc)
              for source = (.source mc)
              do (write (list lang source)
                        :stream s
                        :readably t))))))

(defun snarf-module-deps (lang source)
  (let ((file (deps-file lang source)))
    (when (file-exists-p file)
      (with-input-from-file (s file :if-does-not-exist nil)
        (and s
             (with-standard-io-syntax
               (loop for form = (read s nil nil)
                     while form
                     for (lang source) = form
                     collect (module-cell lang source))))))))

(defun module-static-dependencies (lang source)
  (snarf-module-deps lang source))

(defun deps-file (lang source)
  (make-pathname :defaults (faslize lang source)
                 :type "deps"))

(defmacro with-input-from-source ((stream source) &amp;body body)
  "Read from SOURCE, skipping any #lang declaration."
  `(with-input-from-file (,stream ,source :element-type 'character)
     (skip-hash-lang ,stream)
     ,@body))

(def reader-string (string 'read-module))

(def module-string (string 'module-progn))

(def compile-top-level-string (string '*compile-top-level*))

(def loader-language-exports
  (list (string 'load)
        reader-string
        (string 'extension)
        (string 'script)))</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>;; Make it a function so it can be used before defined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-name">defun</span> loader-language-exports ()
  loader-language-exports)

(<span class="hljs-name">defmacro</span> module-progn-in (<span class="hljs-name">package</span> <span class="hljs-symbol">&amp;body</span> body <span class="hljs-symbol">&amp;environment</span> env)
  <span class="hljs-string">"Resolve a package's expander at macro-expansion time.
Also, ensure that PACKAGE is the current package when BODY is
macro-expanded.

If PACKAGE does not export an expander, `progn' is used instead."</span></pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>; Is expanding the macro this way useful?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (let* ((package-expander (package-expander package :errorp nil))
         (module-progn (or package-expander 'progn))
         (form `(,module-progn ,@body)))
    (expand-in-package form package env)))

(defun user-package (package)
  "Like `resolve-package' but, if a package exists with the same name,
but ending in -USER, and inheriting from that package, return that
instead."
  (assure package
    (with-absolute-package-names ()
      (when-let (base-package (resolve-package package))
        (let* ((user-package-name (fmt "~a-USER" (package-name base-package)))
               (user-package (find-package user-package-name)))
          (or (and user-package
                   (find base-package (package-use-list user-package))
                   user-package)
              base-package))))))</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>;; TODO Is this useful?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-name">defun</span> expand-in-package (<span class="hljs-name">form</span> package env)
  (<span class="hljs-name">let</span> ((<span class="hljs-name">*package*</span> (<span class="hljs-name">user-package</span> (<span class="hljs-name">resolve-package</span> package))))
    (<span class="hljs-name">macroexpand-1</span> form env)))

(<span class="hljs-name">defun</span> cl-read-module (<span class="hljs-name">source</span> stream)
  (<span class="hljs-name">declare</span> (<span class="hljs-name">ignore</span> source))
  (<span class="hljs-name">let</span> ((<span class="hljs-name">eof</span> <span class="hljs-string">"eof"</span>))
    `(progn
       ,@(loop for form = (read stream <span class="hljs-literal">nil</span> eof)
               until (eq form eof)
               collect form))))

(<span class="hljs-name">defun</span> package-compile-top-level? (<span class="hljs-name">package</span>)
  (<span class="hljs-name">and-let*</span> ((<span class="hljs-name">sym</span> (<span class="hljs-name">find-symbol</span> compile-top-level-string package))
             ((<span class="hljs-name">boundp</span> sym)))
    (<span class="hljs-name">symbol-value</span> sym)))

(<span class="hljs-name">defun</span> package-reader (<span class="hljs-name">package</span> <span class="hljs-symbol">&amp;key</span> (<span class="hljs-name">errorp</span> <span class="hljs-literal">t</span>))
  <span class="hljs-string">"Resolve the reader exported by PACKAGE."</span>
  (<span class="hljs-name">flet</span> ((<span class="hljs-name">error*</span> (<span class="hljs-name">&amp;rest</span> args)
           (<span class="hljs-name">if</span> errorp
               (<span class="hljs-name">apply</span> #'error* args)
               (<span class="hljs-name">return-from</span> package-reader <span class="hljs-literal">nil</span>))))
    (<span class="hljs-name">assure</span> (<span class="hljs-name">or</span> symbol null)
      (<span class="hljs-name">let</span> ((<span class="hljs-name">p</span> (<span class="hljs-name">resolve-package</span> package)))
        (<span class="hljs-name">if</span> (<span class="hljs-name">eql</span> p (<span class="hljs-name">find-package</span> <span class="hljs-symbol">:cl</span>))
            'cl-read-module
            (<span class="hljs-name">multiple-value-bind</span> (<span class="hljs-name">sym</span> status) (<span class="hljs-name">find-symbol</span> reader-string p)
              (<span class="hljs-name">cond</span> ((<span class="hljs-name">no</span> sym)</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>; There is no symbol.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                     (error* "No reader defined in package ~a" p))
                    ((not (eql status :external))</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>; There is a symbol, but it’s not external.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                     (error* "Package ~a does not export a reader" p))
                    ((not (fboundp sym))</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>; There is an external symbol, but it’s not
; fbound.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                     (error* "No binding for reader in package ~a" p))
                    (t sym))))))))

(defun reintern (s &amp;aux (p *package*))
  (let ((s (string s)))
    (or (find-symbol s p)
        (error "No symbol named ~a in ~s" s p))))

(defmacro reinterning ((&amp;rest names) &amp;body body)
  `(let ,(loop for name in names
               collect `(,name (reintern ',name)))
     ,@body))

(defun package-expander (package &amp;key (errorp t))
  "Resolve the expander exported by PACKAGE."
  (flet ((error* (&amp;rest args)
           (if errorp
               (apply #'error* args)
               (return-from package-expander nil))))
    (assure (or symbol null)
      (let ((p (resolve-package package)))
        (multiple-value-bind (sym status) (find-symbol module-string p)
          (cond ((no sym)
                 (error* "No expander defined in package ~a" p))
                ((not (eql status :external))
                 (error* "Package ~a does not export an expander" p))
                ((not (fboundp sym))
                 (error* "Expander in package ~a is missing its binding" p))
                ((not (macro-function sym))
                 (error* "Package ~a exports a non-macro expander" p))
                (t (macro-function sym))))))))

(defparameter *file-local-variables*
  '(*package* *readtable*</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>; These seem like a good idea to me.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    *read-base* *read-default-float-format*
    *file-local-variables*)
  "Variables that should be given fresh rebindings while reading in a
  module.

This should be a superset of the variables bound by CL during calls to
`cl:load'.")

(defun expand-module (package source
                      &amp;aux (file-locals *file-local-variables*))
  (let* ((package (resolve-package package))
         (*language* (lang-name package))
         (source (pathname source))
         (*source* source))
    (with-input-from-source (in source)
      (progv file-locals (mapcar #'symbol-value file-locals)
        (let* ((reader (package-reader package))
               (module-form
                 (let ((*package* (user-package package)))
                   (funcall reader source in))))
          module-form)))))

(defun expand-module-for-emacs (lang source)
  (setf lang (resolve-lang lang))
  (values (expand-module lang source)))

(defmacro with-current-module ((lang source) &amp;body body)
  `(macrolet ((current-module-lang () ',lang)
              (current-module-source () ',source)
              (current-module-cell ()
                `(module-cell ',',lang ,',source))
              (current-module ()
                `(find-module ',',lang ,',source))
              (current-module-meta (key)
                `(module-meta ',',lang ,',source ,key)))
     ,@body))

(defun wrap-current-module (form package source)
  (let ((lang (lang-name package)))
    `(with-current-module (,lang ,source)
       ,form)))</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>;; #lang syntax.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defun</span> load-same-name-system (<span class="hljs-name">c</span>)
  (<span class="hljs-name">declare</span> (<span class="hljs-name">ignore</span> c))
  (<span class="hljs-name">invoke-restart</span> 'load-same-name-system))

(<span class="hljs-name">defun</span> lookup-hash-lang (<span class="hljs-name">name</span>)
  (<span class="hljs-name">assure</span> (<span class="hljs-name">or</span> null lang-name)
    (<span class="hljs-name">let*</span> ((<span class="hljs-name">pkg-name</span> (<span class="hljs-name">assure</span> (<span class="hljs-name">satisfies</span> valid-lang-name?)</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>; Set the case as if the string were being
; read, without using <code>read</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                       (coerce-case name)))
           (pkg (resolve-package pkg-name)))
      (or (and pkg (package-name-keyword pkg))
          (restart-case
              (error "No such #lang: ~a" name)
            (load-same-name-system ()
              :test (lambda (c) (declare (ignore c))
                      (asdf:find-system name nil))
              :report (lambda (s)
                        (format s "Load the system named ~a and try again" name))
              (asdf:load-system name)
              (lookup-hash-lang name)))))))

(defun guess-lang+pos (file)
  "If FILE has a #lang line, return the lang and the position at which
the #lang declaration ends."
  (multiple-value-bind (lang pos)
      (file-hash-lang file)
    (if (stringp lang)
        (values (lookup-hash-lang lang) pos)
        (values nil 0))))

(defun resolve-lang (lang)
  (assure lang-name
    (etypecase-of (or lang-name string) lang
      (string (lookup-hash-lang lang))
      (lang-name lang))))

(defun resolve-lang-package (lang)
  (resolve-package (resolve-lang lang)))

(defmacro with-meta-language ((path stream) &amp;body body)
  (with-thunk (body path stream)
    `(call/meta-language ,body ,path ,stream)))

(defun call/meta-language (fn path stream)
  (let* ((next-lang (read-lang-name stream))
         (package (resolve-lang-package next-lang))
         (user-package (user-package package))
         (*package* user-package)
         (forms (funcall fn path stream)))
    `(module-progn-in ,(package-name-keyword package)
       ,@forms)))</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>;; Imports.</p>

            </div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>;; It might seem like this could be moved into a separate file, but
;; that would requiring exposing too much of the above.</p>

            </div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>;; Note that the import macros defined here expand into definition
;; forms from overlord/shadows rather than from cl proper. (E.g.
;; <code>overlord/shadows:defun&#39; rather than</code>cl:defun’.) This is so
;; languages that need to handle imports specially (e.g. Core Lisp)
;; can do so simply by shadowing the relevant definition forms with
;; `macrolet’, instead of having to re-implement everything.</p>

            </div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>;; Hopefully most, if not all, of this code will be replaced once we
;; have a full implementation of import sets.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-name">defcondition</span> bad-macro-import (<span class="hljs-name">overlord-error</span>)
  ((<span class="hljs-name">name</span> <span class="hljs-symbol">:initarg</span> <span class="hljs-symbol">:name</span> <span class="hljs-symbol">:type</span> symbol
         <span class="hljs-symbol">:documentation</span> <span class="hljs-string">"The name of the macro."</span>))
  (<span class="hljs-symbol">:documentation</span> <span class="hljs-string">"Invalid attempt to import something as a macro."</span>))

(<span class="hljs-name">defcondition</span> module-as-macro (<span class="hljs-name">bad-macro-import</span>)
  ()
  (<span class="hljs-symbol">:documentation</span> <span class="hljs-string">"Attempt to import a module as a macro."</span>)
  (<span class="hljs-symbol">:report</span> (<span class="hljs-name">lambda</span> (<span class="hljs-name">c</span> s)
             (<span class="hljs-name">with-slots</span> (<span class="hljs-name">name</span>) c
               (<span class="hljs-name">format</span> s <span class="hljs-string">"Cannot import a module as a macro: ~a"</span>
                       name)))))

(<span class="hljs-name">defcondition</span> macro-as-value (<span class="hljs-name">bad-macro-import</span>)
  ()
  (<span class="hljs-symbol">:documentation</span> <span class="hljs-string">"Attempt to import a macro as a value."</span>)
  (<span class="hljs-symbol">:report</span> (<span class="hljs-name">lambda</span> (<span class="hljs-name">c</span> s)
             (<span class="hljs-name">with-slots</span> (<span class="hljs-name">name</span>) c
               (<span class="hljs-name">format</span> s <span class="hljs-string">"Cannot import a macro as a value: ~a."</span>
                       name)))))

(<span class="hljs-name">defun</span> expand-binding-spec (<span class="hljs-name">spec</span> lang source)
  (<span class="hljs-name">setf</span> source (<span class="hljs-name">merge-pathnames</span> source (<span class="hljs-name">base</span>))
        lang (<span class="hljs-name">lang-name</span> lang))</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>; Avoid calculating the static exports if we don’t need them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (flet ((get-static-exports ()
           (module-static-exports/cache lang source)))
    (etypecase-of binding-spec spec
      ((eql :all)
       (loop for export in (get-static-exports)
             for sym = (intern (string export))
             collect `(,export :as ,sym)))
      ((eql :all-as-functions)
       (loop for export in (get-static-exports)
             for sym = (intern (string export))
             collect `(,export :as #',sym)))
      (list spec))))

(defun guess-source (lang alias)
  (~&gt;&gt; (etypecase-of import-alias alias
         (var-alias alias)
         ((or function-alias macro-alias)
          (second alias)))
       string-downcase
       (make-pathname :name)
       (merge-input-defaults lang)))

(defmacro function-wrapper (fn)
  "Global definition for possible shadowing."
  fn)

(defvar *claimed-module-names* (make-hash-table :size 1024)
  "Table to track claimed modules, so we can warn if they are
  redefined.")

(defun claim-module-name (module lang source)
  "Warn if MODULE is already in use with a different LANG and SOURCE."
  (synchronized ()
    (let* ((table *claimed-module-names*)
           (old-value (gethash module table))
           (new-value (list lang source)))
      (when old-value
        (unless (equal old-value new-value)
          (warn "~s was claimed for ~a in ~a" module source lang)))
      (setf (gethash module table) new-value))))

(defun resolve-lang+source (lang source module base &amp;optional env)
  (setf source (macroexpand source env))
  (flet ((resolve-source (source) (merge-pathnames* source base)))
    (cond</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>; We have the source and the language.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      ((<span class="hljs-name">and</span> source lang)
       (<span class="hljs-name">values</span> (<span class="hljs-name">resolve-lang</span> lang)
               (<span class="hljs-name">resolve-source</span> source)))</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>; We have the source, but not the language.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      (<span class="hljs-name">source</span>
       (<span class="hljs-name">let</span> ((<span class="hljs-name">source</span> (<span class="hljs-name">resolve-source</span> source)))
         (<span class="hljs-name">values</span> (<span class="hljs-name">resolve-lang</span>
                  (<span class="hljs-name">or</span> (<span class="hljs-name">guess-lang+pos</span> source)
                      (<span class="hljs-name">required-argument</span> <span class="hljs-symbol">:as</span>)))
                 source)))</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>; We have the language, but not the source.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      (<span class="hljs-name">lang</span>
       (<span class="hljs-name">values</span> (<span class="hljs-name">resolve-lang</span> lang)
               (<span class="hljs-name">resolve-source</span>
                (<span class="hljs-name">or</span> (<span class="hljs-name">guess-source</span> lang module)
                    (<span class="hljs-name">required-argument</span> <span class="hljs-symbol">:from</span>)))))</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>; We have neither the language nor the source.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      (t (whichever
          (required-argument :as)
          (required-argument :from))))))

(defmacro import (module &amp;body (&amp;key
                                  ((:as lang))
                                  ((:from source))
                                  ((:binding bindings))
                                  values
                                  prefix
                                  function-wrapper)
                  &amp;environment env)
  "Syntax for importing from modules.

Note you can do (import #'foo ...), and the module will be bound as a function."</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>; Ensure we have both the lang and the source.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (<span class="hljs-name">setf</span> (<span class="hljs-name">values</span> lang source)
        (<span class="hljs-name">resolve-lang+source</span> lang source module (<span class="hljs-name">base</span>) env))</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>; Warn if MODULE is already in use with an incompatible language
; and source.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (<span class="hljs-name">claim-module-name</span> module lang source)</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>; Expand the binding and value specs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (<span class="hljs-name">setf</span> (<span class="hljs-name">values</span> bindings values)
        (<span class="hljs-name">bindings+values</span> bindings values
                         <span class="hljs-symbol">:lang</span> lang
                         <span class="hljs-symbol">:source</span> source
                         <span class="hljs-symbol">:prefix</span> prefix))

  (<span class="hljs-name">let</span> ((<span class="hljs-name">lazy</span>? (<span class="hljs-name">null</span> values)))
    `(progn</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>; Importing modules non-lazily has a speed advantage when
; there are no bindings, but it also makes maintenance more
; complex to have two import forms. For now, just use lazy
; imports; maybe re-enable eager loading later.</p>

            </div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>; Also: while it happens to be the case that Serapeum’s `def’
; expands into a symbol macro definition, so switching between
; lazy and eager imports works, it is <em>conceptually</em> weird
; that we can just go ahead and redefine a global lexical as a
; symbol macro.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>       (<span class="hljs-name">import-module/lazy</span> ,module <span class="hljs-symbol">:as</span> ,lang <span class="hljs-symbol">:from</span> ,source)
       #+ () (,(<span class="hljs-name">if</span> lazy? 'import-module/lazy 'import-module)
              ,module <span class="hljs-symbol">:as</span> ,lang <span class="hljs-symbol">:from</span> ,(<span class="hljs-name">merge-pathnames*</span> source (<span class="hljs-name">base</span>)))</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>; We push the check down into a separate macro so we can
; inspect overall macroexpansion without side effects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>       (<span class="hljs-name">check-static-bindings-now</span> ,lang ,source ,(<span class="hljs-name">append</span> bindings values))
       (<span class="hljs-name">macrolet</span> ((<span class="hljs-name">function-wrapper</span> (<span class="hljs-name">fn</span>)
                    ,(<span class="hljs-name">if</span> function-wrapper
                         `(list ',function-wrapper fn)
                         'fn)))
         (<span class="hljs-name">import-bindings</span> ,module ,@bindings)
         (<span class="hljs-name">import-values</span> ,module ,@values))
       (<span class="hljs-name">import-task</span> ,module <span class="hljs-symbol">:as</span> ,lang <span class="hljs-symbol">:from</span> ,source <span class="hljs-symbol">:values</span> ,values <span class="hljs-symbol">:lazy</span> ,lazy?)</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>; Strictly for debuggability.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>       (values ',module ',(append bindings values)))))

(defun bindings+values (bindings values &amp;key lang source prefix)</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>; Avoid redundant calls to module-static-bindings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  (with-static-exports-cache ()
    (flet ((expand (spec)
             (~&gt; (expand-binding-spec spec lang source)
                 canonicalize-bindings
                 (apply-prefix prefix))))
      (values (expand bindings)
              (expand values)))))

(defmacro check-static-bindings-now (lang source bindings)
  "Wrapper around check-static-bindings to force evaluation at compile time.
Can't use eval-when because it has to work for local bindings."
  (check-static-bindings lang source bindings))

(defcondition binding-export-mismatch (overlord-error)
  ((bindings :initarg :bindings :type list)
   (exports :initarg :exports :type list))
  (:report (lambda (c s)
             (with-slots (bindings exports) c
               (format s "Requested bindings do not match exports.~%Bindings: ~s~%Exports: ~s"
                       bindings exports)))))

(defun check-static-bindings (lang source bindings)
  "Check that BINDINGS is free of duplicates. Also, using
`module-static-exports', check that all of the symbols being bound are
actually exported by the module specified by LANG and SOURCE."
  (when bindings
    (when (relative-pathname-p source)
      (setf source (merge-pathnames* source (base))))
    (restart-case
        (progn
          (build (module-cell lang source))
          (let ((exports
                  (module-static-exports lang source))
                (bindings
                  (mapcar (op (import-keyword (first _)))
                          (canonicalize-bindings bindings))))</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>; Check for duplicated bindings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            (<span class="hljs-name">unless</span> (<span class="hljs-name">set-equal</span> bindings (<span class="hljs-name">nub</span> bindings))
              (<span class="hljs-name">error*</span> <span class="hljs-string">"Duplicated bindings."</span>))</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>; Make sure the bindings match the exports.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            (unless (subsetp bindings exports :test #'string=)
              (error 'binding-export-mismatch
                     :bindings bindings
                     :exports exports))))
      (recompile-object-file ()
        :report "Recompile the object file."
        (let ((object-file (faslize lang source))
              (target (module-cell lang source)))
          (delete-file-if-exists object-file)
          (build target)
          (check-static-bindings lang source bindings))))))

(defmacro import-module (module &amp;key as from)
  (let ((req-form `(require-as ',as ,from)))
    (etypecase-of import-alias module
      (var-alias
       `(overlord/shadows:def ,module ,req-form))
      (function-alias
       `(overlord/shadows:defalias ,(second module) ,req-form))
      (macro-alias
       (error 'module-as-macro :name (second module))))))

(defmacro import-module/lazy (module &amp;key as from)
  (let ((lazy-load `(load-module/lazy ',as ,from)))
    (etypecase-of import-alias module
      (var-alias
       `(overlord/shadows:define-symbol-macro ,module ,lazy-load))
      (function-alias
       (let ((fn (second module)))
         `(progn
            (declaim (notinline ,fn))
            (overlord/shadows:defun ,fn () ,lazy-load))))
      (macro-alias
       (error 'module-as-macro :name (second module))))))

(defmacro import-task (module &amp;key as from values lazy)
  (declare (ignorable lazy))
  (let ((task-name
          (etypecase-of import-alias module
            (var-alias module)
            ((or function-alias macro-alias)
             (second module)))))
    `(deftask ,task-name
         (progn
           (require-as ',as ,from)</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>; Put this back if we ever allow non-lazy loaded modules again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>           #+ () ,(let ((req-form `(require-as ',as ,from)))
                    (if lazy
                        req-form
                        `(setf ,module ,req-form)))
           (update-value-bindings ,module ,@values)))))

(defmacro update-value-bindings (module &amp;body values)
  `(progn
     ,@(collecting
         (dolist (clause values)
           (multiple-value-bind (import alias ref) (import+alias+ref clause module)
             (declare (ignore import))
             (collect
                 (etypecase-of import-alias alias
                   (var-alias `(setf ,alias ,ref))
                   (function-alias
                    `(setf (symbol-function ',(second alias)) ,ref))
                   (macro-alias</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>; TODO Why not? It’s just setf of macro-function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    (error 'macro-as-value :name (second alias))))))))))

(defmacro import-bindings (module &amp;body bindings &amp;environment env)
  `(progn
     ,@(mapcar (op (import-binding _ module env))
               (canonicalize-bindings bindings))))

(defmacro import-values (module &amp;body values)
  `(progn
     ,@(mapcar (op (import-value _ module)) values)))

(defun canonicalize-binding (clause)
  (typecase-of binding-designator clause
    (atom (list clause clause))
    ((or function-alias macro-alias) (list (make-keyword (second clause)) clause))
    ((tuple symbol import-alias) clause)
    ((or (tuple (tuple :macro symbol) import-alias)
         (tuple (tuple 'function symbol) import-alias))
     clause)
    (otherwise
     (destructuring-bind (import &amp;key ((:as alias) import)) clause
       (list import alias)))))

(defun canonicalize-bindings (clauses)
  (mapcar #'canonicalize-binding clauses))

(defun apply-prefix (clauses prefix)
  (if (null prefix) clauses
      (flet ((prefix (suffix) (symbolicate prefix suffix)))
        (loop for (import alias) in clauses
              collect (list import
                            (etypecase-of import-alias alias
                              (var-alias (prefix alias))
                              (function-alias `(function ,(prefix (second alias))))
                              (macro-alias `(:macro ,(prefix (second alias))))))))))

(defun import-binding (clause module &amp;optional env)
  (multiple-value-bind (import alias ref) (import+alias+ref clause module)
    (declare (ignore import))
    (etypecase-of import-alias alias
      (var-alias
       `(overlord/shadows:define-symbol-macro ,alias ,ref))
      (function-alias
       (let ((alias (second alias))
             (exp (macroexpand-1 `(function-wrapper ,ref) env)))
         (if (equal exp ref)
             `(progn
                (declaim (notinline ,alias))
                (overlord/shadows:defun ,alias (&amp;rest args)
                  (declare (dynamic-extent args))
                  (apply ,ref args)))
             `(progn
                (overlord/shadows:defalias ,alias
                  (function-wrapper
                   (lambda (&amp;rest args)
                    (declare (dynamic-extent args))
                    (apply ,ref args))))))))
      (macro-alias
       (let ((alias (second alias)))
         (with-gensyms (whole body env)
           `(overlord/shadows:defmacro ,alias (&amp;whole ,whole &amp;body ,body &amp;environment ,env)
              (declare (ignore ,body))
              (funcall ,ref ,whole ,env))))))))

(defun import-value (clause module)
  (multiple-value-bind (import alias ref) (import+alias+ref clause module)
    (declare (ignore import))
    (etypecase-of import-alias alias
      (var-alias
       `(overlord/shadows:def ,alias ,ref))
      (function-alias
       (let ((alias (second alias)))
         `(overlord/shadows:defalias ,alias
            (function-wrapper ,ref))))
      (macro-alias
       (error 'macro-as-value :name (second alias))))))

(defun import+alias+ref (clause module)
  (destructuring-bind (import alias) (canonicalize-binding clause)
    (let* ((key (import-keyword import))
           (ref `(module-ref* ,module ',key)))
      (values import alias ref))))

(defun import-keyword (import)
  (if (symbolp import)
      (make-keyword import)
      (make-keyword (second import))))

(defmacro import/local (mod &amp;body (&amp;key from as binding values)
                        &amp;environment env)
  (mvlet* ((lang source (resolve-lang+source as from mod (base) env))
           (import-form `(load-module/lazy ',lang ,source)))</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>; TODO If we knew that no macros were being imported, we could
; give the module a local binding and not have to look it up
; every time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    `(progn
       ,(etypecase-of import-alias mod
          (var-alias
           `(overlord/shadows:define-symbol-macro ,mod ,import-form))
          (function-alias
           (let ((fn (second mod)))
             `(overlord/shadows:defun ,fn (&amp;rest args)
                (apply ,import-form args))))
          (macro-alias
           (error 'module-as-macro :name (second mod))))
       (import-bindings ,mod ,@binding)
       (import-values ,mod ,@values))))

(defmacro with-imports ((mod &amp;key from as binding values) &amp;body body)
  "A version of `import' with local scope."
  `(local*
     (import/local ,mod
       :from ,from
       :as ,as
       :binding ,binding
       :values ,values)
     (progn ,@body)))

(defmacro import-as-package (package-name
                             &amp;body body
                             &amp;key ((:as lang))
                                  ((:from source) (guess-source lang package-name))
                                  ((:binding bindings))
                                  values
                                  prefix
                             &amp;allow-other-keys)
  "Like `import', but instead of creating bindings in the current
package, create a new package named PACKAGE-NAME which exports all of
the symbols bound in the body of the import form."
  (multiple-value-bind (bindings values)
      (bindings+values bindings values
                       :lang lang
                       :source source
                       :prefix prefix)
    (let ((body (list* :binding bindings
                       :values values
                       (remove-from-plist body :prefix :binding :values))))
      `(progn
         (import-&gt;defpackage ,package-name ,@body)</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>; The helper macro must be expanded after package-name has
; been defined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>         (import-as-package-aux ,package-name ,@body)))))

(defmacro import-&gt;defpackage (package-name
                              &amp;body (&amp;rest body
                                     &amp;key
                                       ((:binding bindings))
                                       values
                                     &amp;allow-other-keys))
  (declare (ignore body))
  `(defpackage ,package-name
     (:use)
     (:export ,@(nub (loop for (nil alias) in (append bindings values)
                           collect (make-keyword
                                    (etypecase-of import-alias alias
                                      (var-alias alias)
                                      (function-alias (second alias))
                                      (macro-alias (second alias)))))))))

(defmacro import-as-package-aux (package-name &amp;body
                                                (&amp;rest body
                                                 &amp;key ((:binding bindings))
                                                      values
                                                 &amp;allow-other-keys))
  (let ((p (assure package (find-package package-name))))
    (labels ((intern* (sym)
               (intern (string sym) p))
             (intern-spec (spec)
               (loop for (key alias) in spec
                     collect `(,key ,(etypecase-of import-alias alias
                                       (var-alias (intern* alias))
                                       (function-alias
                                        (let ((alias (second alias)))
                                          `(function ,(intern* alias))))
                                       (macro-alias
                                        (let ((alias (second alias)))
                                          `(:macro ,(intern* alias)))))))))
      (let ((module-binding (symbolicate '%module-for-package- (package-name p))))
        `(import ,module-binding
           :binding ,(intern-spec bindings)
           :values  ,(intern-spec values)
           ,@body)))))</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
